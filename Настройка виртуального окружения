	Виртуальные окружения

Вы уже знаете, что pip устанавливает пакеты в одно из двух окружений — в общесистемное или пользовательское. Интерпретатор Python при импорте модуля или пакета ищет его сначала в пользовательском окружении, затем — в общесистемном. Такая последовательность позволяет пользователю иметь нужные именно ему версии библиотек и Python-программ.

Но даже двух окружений недостаточно, когда программист начинает работать с несколькими проектами, ведь разные проекты могут иметь разные наборы зависимостей. Еще более тяжелый случай: разные проекты могут зависеть от общей библиотеки, но требовать разные ее версии — тогда происходит конфликт версий.

Очевидно, что разработчику на Python нужен какой-то механизм, позволяющий содержать разные проекты в изолированных песочницах. Такой механизм существует. Он называется виртуальные окружения.

	Устройство виртуальных окружений

Каждое виртуальное окружение представляет собой директорию. Ее содержимое структурно напоминает общесистемное окружение — поддиректории соответственно названы и наполнены. Давайте рассмотрим пример:

tree env

env
├── bin
│   ├── activate
│   …
│   ├── pip
│   …
│   └── python3 -> …/python3
├── lib
│   └── python3.6
│       └── site-packages
│           ├── pip
│           │   ├── …
│           …
│           └── setuptools-40.6.2.dist-info
│               ├── …
…
В директории виртуального окружения находится директория bin/, внутри которой расположены:

1.Копия интерпретатора под именем python3 (символическая ссылка на оригинал)

2.Копия исполняемого файла pip

В соседней директории по пути lib/python3.6/site-packages есть библиотеки, уже установленные в окружение. Как правило, только что созданное окружение имеет:

1.Установленный пакет pip (исполняемый файл bin/pip — его точка входа)

2.Пакет Setuptools

Эти два пакета составляют необходимый минимум для разработки проекта на Python.

При работе в окружении нужно запускать не системные Python и pip, а исполняемые файлы из директории bin. Когда интерпретатор Python находится в окружении, он знает, где находятся все доступные пакеты. Интерпретатор находит их по относительному пути ../lib/python3.6. В таком случае копия pip из директории bin/ устанавливает пакеты в это же окружение, не затрагивая систему. Получается та самая изоляция, о которой мы говорили в начале урока.

	Создание виртуального окружения
Вручную создавать всю описанную иерархию директорий и файлов не нужно — для этого есть специальный модуль venv.

В macOS и Windows этот модуль входит в поставку Python. На Ubuntu его нужно установить отдельно командой:

sudo apt install python3-venv
Проверим, что модуль установился и готов к использованию:

python3 -m venv --help

usage: venv [-h] [--system-site-packages] [--symlinks | --copies] [--clear] [--upgrade] [--without-pip] [--prompt PROMPT] ENV_DIR [ENV_DIR ...]
Обычно окружение создается командой python3 -m venv имя_окружения. Давайте попробуем создать виртуальное окружение и установить туда пакет cowsay:


Вы можете видеть, что пакет устанавливается вместе с точкой входа, которую можно вызвать командой first_venv/bin/cowsay. Также сам пакет становится доступен интерпретатору, но только тому, что был запущен из окружения.

В таком виде виртуальное окружение уже можно использовать полноценно. Но постоянно вводить команды с префиксом first_venv/bin/ не очень удобно. Есть способ упростить вызов команд, доступных в окружении — это активация.

	Активация окружения
При создании окружения в поддиректорию bin помещается сценарий оболочки, который на macOS и Ubuntu называется activate, а на Windows — activate.bat. Чтобы выполнить этот сценарий, нужно вызвать команду:

на macOS и Ubuntu:
source first_venv/bin/activate
на Windows:
C:\> first_venv\Scripts\activate.bat
В команде выше обратите внимание, что в Windows поддиректория с исполняемыми файлами называется не bin, а Scripts.

После активации отпала необходимость указывать путь до вызываемого исполняемого файла. Теперь cowsay и python вызываются без префикса, но это все те же команды из окружения.

Еще изменилось приглашение оболочки: в нем стало отображаться имя окружения. Это работает на macOS и Ubuntu и всегда напоминает, что мы находимся в виртуальном окружении.

Деактивация окружения делается командой deactivate, которая становится доступна после активации.

Активация и деактивация окружения влияют только на текущую сессию — то есть заметны только в этом конкретном терминале. Это удобно, потому что так можно иметь несколько окружений и активировать их одновременно в разных окнах терминала.

	Выводы
Виртуальные окружения — мощный и удобный инструмент изоляции программ друг от друга и от системы. Изоляция позволяет использовать даже разные версии Python в разных окружениях — при работе над проектами разного "возраста" такое часто бывает жизненно необходимо! Поэтому мы, как обычно, рекомендуем добавить виртуальные окружения в список тем для более глубокого изучения в дальнейшем.




	Cкрипты

В интерпретируемых языках от написания кода до запуска — всего один шаг. Ничего не нужно компилировать в машинный код.

Всю работу делает интерпретатор, которому достаточно подать на вход скрипт — программу на интерпретируемом языке. Внутри этой программы записаны простые последовательности команд, которые компьютеру нужно выполнить.

Если на каком-то языке удобно писать скрипты, его называют «скриптовым языком» или «языком для написания сценариев».

	Скрипты на Python
Python отлично подходит на роль скриптового языка. Последовательность команд в простых сценариях не нужно никак оформлять и запускать скрипты максимально просто. Мы просто пишем команды одну за другой в файл:

# file <script.py>
print('Hello, world!')
print('This is a python-script!')
Затем мы просто вызываем интерпретатор с полученным файлом на входе:

python3 script.py

Hello, world!
This is a python-script!

У Python много полезных модулей и функций, входящих в поставку. Поэтому его часто используют для автоматизации различных задач, которые не хочется выполнять вручную при работе на компьютере. К тому же написание скриптов — отличная отправная точка для тех, кто только начинает знакомиться с программированием.

	Скрипты и shebang
	
В Linux, macOS, BSD и других unix-подобных операционных системах командные оболочки умеют запускать скрипты на любых языках, в том числе и на Python. При этом скрипты сообщают оболочке, какой интерпретатор нужно вызывать для выполнения сценария.

Интерпретатор указывается специальной строкой в самой первой строчке файла скрипта, которая называется shebang. Это название произошло от первых двух символов такой строчки: # называется sharp, а ! — bang.

Типичный shebang выглядит так:

#!/usr/bin/python3
После символов #! идет путь до интерпретатора. При запуске скрипта с shebang командная оболочка читает первую строку и пробует запустить указанный интерпретатор. Если скрипту с указанным shebang дать права на исполнение, то интерпретатор в командной строке можно не указывать:

cat script.py

#!/usr/bin/python3
print('Hello!')

chmod +x script.py

./script.py

Hello!

	Shebang и разные версии Python

В целом shebang — штука довольно простая, когда интерпретатор в системе ровно один. Но мы с вами знаем, что версий Python в системе может быть установлено несколько. Более того, в виртуальном окружении путь к интерпретатору будет отличаться от /usr/bin и будет разным в разных окружениях.

Как сделать так, чтобы скрипт запускался всегда с нужной версией Python? Нужно всего лишь не указывать путь до команды python напрямую, а использовать программу env.

Эта программа умеет находить и запускать программы с учетом переменных окружения. При активации виртуального окружения модифицируется переменная $PATH, поэтому env будет запускать именно ту версию интерпретатора, которая нам нужна. Нужная версия просто найдется раньше, потому что путь до исполняемых файлов окружения добавляется в начало $PATH.

А теперь рассмотрим правильный способ указывать shebang в проектах на python:

#!/usr/bin/env python3
print('Hello!')

Путь до env указан конкретный, потому что эта программа практически всегда располагается именно там и не встречается в нескольких версиях.























