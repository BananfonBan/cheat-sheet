	Виртуальные окружения

Вы уже знаете, что pip устанавливает пакеты в одно из двух окружений — в общесистемное или пользовательское. Интерпретатор Python при импорте модуля или пакета ищет его сначала в пользовательском окружении, затем — в общесистемном. Такая последовательность позволяет пользователю иметь нужные именно ему версии библиотек и Python-программ.

Но даже двух окружений недостаточно, когда программист начинает работать с несколькими проектами, ведь разные проекты могут иметь разные наборы зависимостей. Еще более тяжелый случай: разные проекты могут зависеть от общей библиотеки, но требовать разные ее версии — тогда происходит конфликт версий.

Очевидно, что разработчику на Python нужен какой-то механизм, позволяющий содержать разные проекты в изолированных песочницах. Такой механизм существует. Он называется виртуальные окружения.

	Устройство виртуальных окружений

Каждое виртуальное окружение представляет собой директорию. Ее содержимое структурно напоминает общесистемное окружение — поддиректории соответственно названы и наполнены. Давайте рассмотрим пример:

tree env

env
├── bin
│   ├── activate
│   …
│   ├── pip
│   …
│   └── python3 -> …/python3
├── lib
│   └── python3.6
│       └── site-packages
│           ├── pip
│           │   ├── …
│           …
│           └── setuptools-40.6.2.dist-info
│               ├── …
…
В директории виртуального окружения находится директория bin/, внутри которой расположены:

1.Копия интерпретатора под именем python3 (символическая ссылка на оригинал)

2.Копия исполняемого файла pip

В соседней директории по пути lib/python3.6/site-packages есть библиотеки, уже установленные в окружение. Как правило, только что созданное окружение имеет:

1.Установленный пакет pip (исполняемый файл bin/pip — его точка входа)

2.Пакет Setuptools

Эти два пакета составляют необходимый минимум для разработки проекта на Python.

При работе в окружении нужно запускать не системные Python и pip, а исполняемые файлы из директории bin. Когда интерпретатор Python находится в окружении, он знает, где находятся все доступные пакеты. Интерпретатор находит их по относительному пути ../lib/python3.6. В таком случае копия pip из директории bin/ устанавливает пакеты в это же окружение, не затрагивая систему. Получается та самая изоляция, о которой мы говорили в начале урока.

	Создание виртуального окружения
Вручную создавать всю описанную иерархию директорий и файлов не нужно — для этого есть специальный модуль venv.

В macOS и Windows этот модуль входит в поставку Python. На Ubuntu его нужно установить отдельно командой:

sudo apt install python3-venv
Проверим, что модуль установился и готов к использованию:

python3 -m venv --help

usage: venv [-h] [--system-site-packages] [--symlinks | --copies] [--clear] [--upgrade] [--without-pip] [--prompt PROMPT] ENV_DIR [ENV_DIR ...]
Обычно окружение создается командой python3 -m venv имя_окружения. Давайте попробуем создать виртуальное окружение и установить туда пакет cowsay:


Вы можете видеть, что пакет устанавливается вместе с точкой входа, которую можно вызвать командой first_venv/bin/cowsay. Также сам пакет становится доступен интерпретатору, но только тому, что был запущен из окружения.

В таком виде виртуальное окружение уже можно использовать полноценно. Но постоянно вводить команды с префиксом first_venv/bin/ не очень удобно. Есть способ упростить вызов команд, доступных в окружении — это активация.

	Активация окружения
При создании окружения в поддиректорию bin помещается сценарий оболочки, который на macOS и Ubuntu называется activate, а на Windows — activate.bat. Чтобы выполнить этот сценарий, нужно вызвать команду:

на macOS и Ubuntu:
source first_venv/bin/activate
на Windows:
C:\> first_venv\Scripts\activate.bat
В команде выше обратите внимание, что в Windows поддиректория с исполняемыми файлами называется не bin, а Scripts.

После активации отпала необходимость указывать путь до вызываемого исполняемого файла. Теперь cowsay и python вызываются без префикса, но это все те же команды из окружения.

Еще изменилось приглашение оболочки: в нем стало отображаться имя окружения. Это работает на macOS и Ubuntu и всегда напоминает, что мы находимся в виртуальном окружении.

Деактивация окружения делается командой deactivate, которая становится доступна после активации.

Активация и деактивация окружения влияют только на текущую сессию — то есть заметны только в этом конкретном терминале. Это удобно, потому что так можно иметь несколько окружений и активировать их одновременно в разных окнах терминала.

	Выводы
Виртуальные окружения — мощный и удобный инструмент изоляции программ друг от друга и от системы. Изоляция позволяет использовать даже разные версии Python в разных окружениях — при работе над проектами разного "возраста" такое часто бывает жизненно необходимо! Поэтому мы, как обычно, рекомендуем добавить виртуальные окружения в список тем для более глубокого изучения в дальнейшем.




	Cкрипты

В интерпретируемых языках от написания кода до запуска — всего один шаг. Ничего не нужно компилировать в машинный код.

Всю работу делает интерпретатор, которому достаточно подать на вход скрипт — программу на интерпретируемом языке. Внутри этой программы записаны простые последовательности команд, которые компьютеру нужно выполнить.

Если на каком-то языке удобно писать скрипты, его называют «скриптовым языком» или «языком для написания сценариев».

	Скрипты на Python
Python отлично подходит на роль скриптового языка. Последовательность команд в простых сценариях не нужно никак оформлять и запускать скрипты максимально просто. Мы просто пишем команды одну за другой в файл:

# file <script.py>
print('Hello, world!')
print('This is a python-script!')
Затем мы просто вызываем интерпретатор с полученным файлом на входе:

python3 script.py

Hello, world!
This is a python-script!

У Python много полезных модулей и функций, входящих в поставку. Поэтому его часто используют для автоматизации различных задач, которые не хочется выполнять вручную при работе на компьютере. К тому же написание скриптов — отличная отправная точка для тех, кто только начинает знакомиться с программированием.

	Скрипты и shebang
	
В Linux, macOS, BSD и других unix-подобных операционных системах командные оболочки умеют запускать скрипты на любых языках, в том числе и на Python. При этом скрипты сообщают оболочке, какой интерпретатор нужно вызывать для выполнения сценария.

Интерпретатор указывается специальной строкой в самой первой строчке файла скрипта, которая называется shebang. Это название произошло от первых двух символов такой строчки: # называется sharp, а ! — bang.

Типичный shebang выглядит так:

#!/usr/bin/python3
После символов #! идет путь до интерпретатора. При запуске скрипта с shebang командная оболочка читает первую строку и пробует запустить указанный интерпретатор. Если скрипту с указанным shebang дать права на исполнение, то интерпретатор в командной строке можно не указывать:

cat script.py

#!/usr/bin/python3
print('Hello!')

chmod +x script.py

./script.py

Hello!

	Shebang и разные версии Python

В целом shebang — штука довольно простая, когда интерпретатор в системе ровно один. Но мы с вами знаем, что версий Python в системе может быть установлено несколько. Более того, в виртуальном окружении путь к интерпретатору будет отличаться от /usr/bin и будет разным в разных окружениях.

Как сделать так, чтобы скрипт запускался всегда с нужной версией Python? Нужно всего лишь не указывать путь до команды python напрямую, а использовать программу env.

Эта программа умеет находить и запускать программы с учетом переменных окружения. При активации виртуального окружения модифицируется переменная $PATH, поэтому env будет запускать именно ту версию интерпретатора, которая нам нужна. Нужная версия просто найдется раньше, потому что путь до исполняемых файлов окружения добавляется в начало $PATH.

А теперь рассмотрим правильный способ указывать shebang в проектах на python:

#!/usr/bin/env python3
print('Hello!')

Путь до env указан конкретный, потому что эта программа практически всегда располагается именно там и не встречается в нескольких версиях.



	Запускаемые модули и пакеты—

	Запускаемые пакеты
	
Представим, что у нас есть файл с кодом, который мы запускаем как скрипт. Файл разрастается, в нем появляются функции и прочие определения. В какой-то момент мы понимаем, что хотим переиспользовать функцию из этого модуля в другом модуле. Значит, нужно импортировать. В этом уроке мы разберемся, как работает импорт скриптов.

	Импортирование скриптов
	
Смоделируем описанную выше ситуацию. Так будет выглядеть исходный скрипт:

# file <first_script.py>

def greet(who):
    print(f'Hello, {who}!')

greet('Bob')
greet('Ann')


Теперь посмотрим на новый скрипт, в котором мы хотим переиспользовать функцию greet из первого скрипта:

# file <second_script.py>

from first_script import greet

greet('Thomas')


Запустим первый скрипт, а затем — второй. Оба файла расположены в текущей директории:

python3 first_script.py

Hello, Bob!
Hello, Ann!

python3 second_script.py

Hello, Bob!
Hello, Ann!
Hello, Thomas!


При выполнении второго скрипта выполнился и первый, хотя мы всего лишь импортировали из него одну функцию — такова цена за простоту написания скриптов.

Файл первого скрипта содержит определения и непосредственные действия, поэтому при загрузке файла при импорте модуля эти действия будут выполнены.

Теперь представьте, что мы бы импортировали скрипт, в котором не просто что-то печатается на экран, а удаляются какие-то файлы.

Выходит, нам нужно как-то различать ситуации двух типов:

1. Модуль работает как скрипт — выполняем побочные действия
2. Модуль или его содержимое импортируются — не выполняем побочные действия


	Специальная переменная __name__

Рассмотрим механизм импорта при загрузке модуля в первый раз — а именно первый для текущего запуска интерпретатора.

Во время первой загрузки интерпретатор добавляет в модуль несколько переменных специального вида. Этих переменных довольно много, но нам пока интересна одна — переменная __name__.

Кажется, что у переменной необычное имя — в нем целых четыре символа подчеркивания. На самом деле такие имена часто встречаются в Python-коде и как правило имеют какой-то специальный смысл. Опытный разработчик обычно помнит наизусть пару десятков таких переменных, поэтому про эти переменные любят спрашивать на собеседованиях.

Посмотрим, что хранит переменная __name__ в каждом конкретном случае:

1.Если происходит обычный импорт, то эта переменная содержит полное имя модуля

2.Если происходит запуск в качестве скрипта, то переменная получает специальное значение — строку '__main__'

Глядя на значение этой переменной, мы можем отличать запуск в качестве скрипта от импортирования.

Слово main используется во многих языках для именования функции, которая вызывается автоматически при старте программы. Потому и в Python это слово используется в похожем смысле.

Давайте вернемся к нашему примеру и перепишем first_script.py с применением этого нового знания:

# file <first_script.py>

def greet(who):
    print(f'Hello, {who}!')

if __name__ == '__main__':
    greet('Bob')
    greet('Ann')

Теперь наш скрипт не будет приветствовать Боба и Энн, если мы будем импортировать модуль.

	
	Функция main
Наш скрипт first_script.py уже достаточно хорош, но можно немного его улучшить.

В теле условия if __name__… перечислен набор действий, которые выполняются при запуске скрипта. Со временем таких действий может стать достаточно много.

Нередко происходят ситуации, когда нужно переиспользовать этот кусок кода. Поэтому существует соглашение: в теле условия if __name__… делают всего один вызов функции main без аргументов. Эту функцию объявляют выше в этом же модуле. При этом само условие принято располагать в самом конце модуля скрипта.

С учетом всех описанных рекомендаций финальная версия скрипта first_script.py будет выглядеть так:

#!/usr/bin/env python3

def greet(who):
    print(f'Hello, {who}!')

def main():
    greet('Bob')
    greet('Ann')

if __name__ == '__main__':
    main()

Такой скрипт можно:

1.Запускать непосредственно

2.Запускать из других скриптов, вызывая функцию main

3.Использовать как библиотеку

	Запускаемые пакеты
	
Рассмотрим немного необычный, но все же встречающийся случай — запуск пакета.

Может показаться, что раз при загрузке пакета всегда загружается модуль __init__.py, то функцию main и условие нужно располагать в нем.

Но запуск пакетов реализован несколько иначе: при загрузке пакета интерпретатор ищет __main__.py и выполняет его как скрипт. Здесь мы не будем углубляться в причины — просто запомним, что исполняемые пакеты всегда содержат скрипт __main__.py.

Когда может понадобиться запуск пакета? Возьмем для примера один небольшой скрипт. Со временем кода в нем становилось все больше — настолько много, что этот скрипт стало совершенно невозможно поддерживать.

Представим, что мы решили превратить один модуль в пакет, содержащий модули. Но как такой пакет в дальнейшем запускать? Как раз в этом нам поможет модуль __main__.py.





















