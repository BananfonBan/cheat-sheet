	Виртуальные окружения

Вы уже знаете, что pip устанавливает пакеты в одно из двух окружений — в общесистемное или пользовательское. Интерпретатор Python при импорте модуля или пакета ищет его сначала в пользовательском окружении, затем — в общесистемном. Такая последовательность позволяет пользователю иметь нужные именно ему версии библиотек и Python-программ.

Но даже двух окружений недостаточно, когда программист начинает работать с несколькими проектами, ведь разные проекты могут иметь разные наборы зависимостей. Еще более тяжелый случай: разные проекты могут зависеть от общей библиотеки, но требовать разные ее версии — тогда происходит конфликт версий.

Очевидно, что разработчику на Python нужен какой-то механизм, позволяющий содержать разные проекты в изолированных песочницах. Такой механизм существует. Он называется виртуальные окружения.

	Устройство виртуальных окружений

Каждое виртуальное окружение представляет собой директорию. Ее содержимое структурно напоминает общесистемное окружение — поддиректории соответственно названы и наполнены. Давайте рассмотрим пример:

tree env

env
├── bin
│   ├── activate
│   …
│   ├── pip
│   …
│   └── python3 -> …/python3
├── lib
│   └── python3.6
│       └── site-packages
│           ├── pip
│           │   ├── …
│           …
│           └── setuptools-40.6.2.dist-info
│               ├── …
…
В директории виртуального окружения находится директория bin/, внутри которой расположены:

1.Копия интерпретатора под именем python3 (символическая ссылка на оригинал)

2.Копия исполняемого файла pip

В соседней директории по пути lib/python3.6/site-packages есть библиотеки, уже установленные в окружение. Как правило, только что созданное окружение имеет:

1.Установленный пакет pip (исполняемый файл bin/pip — его точка входа)

2.Пакет Setuptools

Эти два пакета составляют необходимый минимум для разработки проекта на Python.

При работе в окружении нужно запускать не системные Python и pip, а исполняемые файлы из директории bin. Когда интерпретатор Python находится в окружении, он знает, где находятся все доступные пакеты. Интерпретатор находит их по относительному пути ../lib/python3.6. В таком случае копия pip из директории bin/ устанавливает пакеты в это же окружение, не затрагивая систему. Получается та самая изоляция, о которой мы говорили в начале урока.

	Создание виртуального окружения
Вручную создавать всю описанную иерархию директорий и файлов не нужно — для этого есть специальный модуль venv.

В macOS и Windows этот модуль входит в поставку Python. На Ubuntu его нужно установить отдельно командой:

sudo apt install python3-venv
Проверим, что модуль установился и готов к использованию:

python3 -m venv --help

usage: venv [-h] [--system-site-packages] [--symlinks | --copies] [--clear] [--upgrade] [--without-pip] [--prompt PROMPT] ENV_DIR [ENV_DIR ...]
Обычно окружение создается командой python3 -m venv имя_окружения. Давайте попробуем создать виртуальное окружение и установить туда пакет cowsay:


Вы можете видеть, что пакет устанавливается вместе с точкой входа, которую можно вызвать командой first_venv/bin/cowsay. Также сам пакет становится доступен интерпретатору, но только тому, что был запущен из окружения.

В таком виде виртуальное окружение уже можно использовать полноценно. Но постоянно вводить команды с префиксом first_venv/bin/ не очень удобно. Есть способ упростить вызов команд, доступных в окружении — это активация.

	Активация окружения
При создании окружения в поддиректорию bin помещается сценарий оболочки, который на macOS и Ubuntu называется activate, а на Windows — activate.bat. Чтобы выполнить этот сценарий, нужно вызвать команду:

на macOS и Ubuntu:
source first_venv/bin/activate
на Windows:
C:\> first_venv\Scripts\activate.bat
В команде выше обратите внимание, что в Windows поддиректория с исполняемыми файлами называется не bin, а Scripts.

После активации отпала необходимость указывать путь до вызываемого исполняемого файла. Теперь cowsay и python вызываются без префикса, но это все те же команды из окружения.

Еще изменилось приглашение оболочки: в нем стало отображаться имя окружения. Это работает на macOS и Ubuntu и всегда напоминает, что мы находимся в виртуальном окружении.

Деактивация окружения делается командой deactivate, которая становится доступна после активации.

Активация и деактивация окружения влияют только на текущую сессию — то есть заметны только в этом конкретном терминале. Это удобно, потому что так можно иметь несколько окружений и активировать их одновременно в разных окнах терминала.

	Выводы
Виртуальные окружения — мощный и удобный инструмент изоляции программ друг от друга и от системы. Изоляция позволяет использовать даже разные версии Python в разных окружениях — при работе над проектами разного "возраста" такое часто бывает жизненно необходимо! Поэтому мы, как обычно, рекомендуем добавить виртуальные окружения в список тем для более глубокого изучения в дальнейшем.




	Cкрипты

В интерпретируемых языках от написания кода до запуска — всего один шаг. Ничего не нужно компилировать в машинный код.

Всю работу делает интерпретатор, которому достаточно подать на вход скрипт — программу на интерпретируемом языке. Внутри этой программы записаны простые последовательности команд, которые компьютеру нужно выполнить.

Если на каком-то языке удобно писать скрипты, его называют «скриптовым языком» или «языком для написания сценариев».

	Скрипты на Python
Python отлично подходит на роль скриптового языка. Последовательность команд в простых сценариях не нужно никак оформлять и запускать скрипты максимально просто. Мы просто пишем команды одну за другой в файл:

# file <script.py>
print('Hello, world!')
print('This is a python-script!')
Затем мы просто вызываем интерпретатор с полученным файлом на входе:

python3 script.py

Hello, world!
This is a python-script!

У Python много полезных модулей и функций, входящих в поставку. Поэтому его часто используют для автоматизации различных задач, которые не хочется выполнять вручную при работе на компьютере. К тому же написание скриптов — отличная отправная точка для тех, кто только начинает знакомиться с программированием.

	Скрипты и shebang
	
В Linux, macOS, BSD и других unix-подобных операционных системах командные оболочки умеют запускать скрипты на любых языках, в том числе и на Python. При этом скрипты сообщают оболочке, какой интерпретатор нужно вызывать для выполнения сценария.

Интерпретатор указывается специальной строкой в самой первой строчке файла скрипта, которая называется shebang. Это название произошло от первых двух символов такой строчки: # называется sharp, а ! — bang.

Типичный shebang выглядит так:

#!/usr/bin/python3
После символов #! идет путь до интерпретатора. При запуске скрипта с shebang командная оболочка читает первую строку и пробует запустить указанный интерпретатор. Если скрипту с указанным shebang дать права на исполнение, то интерпретатор в командной строке можно не указывать:

cat script.py

#!/usr/bin/python3
print('Hello!')

chmod +x script.py

./script.py

Hello!

	Shebang и разные версии Python

В целом shebang — штука довольно простая, когда интерпретатор в системе ровно один. Но мы с вами знаем, что версий Python в системе может быть установлено несколько. Более того, в виртуальном окружении путь к интерпретатору будет отличаться от /usr/bin и будет разным в разных окружениях.

Как сделать так, чтобы скрипт запускался всегда с нужной версией Python? Нужно всего лишь не указывать путь до команды python напрямую, а использовать программу env.

Эта программа умеет находить и запускать программы с учетом переменных окружения. При активации виртуального окружения модифицируется переменная $PATH, поэтому env будет запускать именно ту версию интерпретатора, которая нам нужна. Нужная версия просто найдется раньше, потому что путь до исполняемых файлов окружения добавляется в начало $PATH.

А теперь рассмотрим правильный способ указывать shebang в проектах на python:

#!/usr/bin/env python3
print('Hello!')

Путь до env указан конкретный, потому что эта программа практически всегда располагается именно там и не встречается в нескольких версиях.



	Запускаемые модули и пакеты—

	Запускаемые пакеты
	
Представим, что у нас есть файл с кодом, который мы запускаем как скрипт. Файл разрастается, в нем появляются функции и прочие определения. В какой-то момент мы понимаем, что хотим переиспользовать функцию из этого модуля в другом модуле. Значит, нужно импортировать. В этом уроке мы разберемся, как работает импорт скриптов.

	Импортирование скриптов
	
Смоделируем описанную выше ситуацию. Так будет выглядеть исходный скрипт:

# file <first_script.py>

def greet(who):
    print(f'Hello, {who}!')

greet('Bob')
greet('Ann')


Теперь посмотрим на новый скрипт, в котором мы хотим переиспользовать функцию greet из первого скрипта:

# file <second_script.py>

from first_script import greet

greet('Thomas')


Запустим первый скрипт, а затем — второй. Оба файла расположены в текущей директории:

python3 first_script.py

Hello, Bob!
Hello, Ann!

python3 second_script.py

Hello, Bob!
Hello, Ann!
Hello, Thomas!


При выполнении второго скрипта выполнился и первый, хотя мы всего лишь импортировали из него одну функцию — такова цена за простоту написания скриптов.

Файл первого скрипта содержит определения и непосредственные действия, поэтому при загрузке файла при импорте модуля эти действия будут выполнены.

Теперь представьте, что мы бы импортировали скрипт, в котором не просто что-то печатается на экран, а удаляются какие-то файлы.

Выходит, нам нужно как-то различать ситуации двух типов:

1. Модуль работает как скрипт — выполняем побочные действия
2. Модуль или его содержимое импортируются — не выполняем побочные действия


	Специальная переменная __name__

Рассмотрим механизм импорта при загрузке модуля в первый раз — а именно первый для текущего запуска интерпретатора.

Во время первой загрузки интерпретатор добавляет в модуль несколько переменных специального вида. Этих переменных довольно много, но нам пока интересна одна — переменная __name__.

Кажется, что у переменной необычное имя — в нем целых четыре символа подчеркивания. На самом деле такие имена часто встречаются в Python-коде и как правило имеют какой-то специальный смысл. Опытный разработчик обычно помнит наизусть пару десятков таких переменных, поэтому про эти переменные любят спрашивать на собеседованиях.

Посмотрим, что хранит переменная __name__ в каждом конкретном случае:

1.Если происходит обычный импорт, то эта переменная содержит полное имя модуля

2.Если происходит запуск в качестве скрипта, то переменная получает специальное значение — строку '__main__'

Глядя на значение этой переменной, мы можем отличать запуск в качестве скрипта от импортирования.

Слово main используется во многих языках для именования функции, которая вызывается автоматически при старте программы. Потому и в Python это слово используется в похожем смысле.

Давайте вернемся к нашему примеру и перепишем first_script.py с применением этого нового знания:

# file <first_script.py>

def greet(who):
    print(f'Hello, {who}!')

if __name__ == '__main__':
    greet('Bob')
    greet('Ann')

Теперь наш скрипт не будет приветствовать Боба и Энн, если мы будем импортировать модуль.

	
	Функция main
Наш скрипт first_script.py уже достаточно хорош, но можно немного его улучшить.

В теле условия if __name__… перечислен набор действий, которые выполняются при запуске скрипта. Со временем таких действий может стать достаточно много.

Нередко происходят ситуации, когда нужно переиспользовать этот кусок кода. Поэтому существует соглашение: в теле условия if __name__… делают всего один вызов функции main без аргументов. Эту функцию объявляют выше в этом же модуле. При этом само условие принято располагать в самом конце модуля скрипта.

С учетом всех описанных рекомендаций финальная версия скрипта first_script.py будет выглядеть так:

#!/usr/bin/env python3

def greet(who):
    print(f'Hello, {who}!')

def main():
    greet('Bob')
    greet('Ann')

if __name__ == '__main__':
    main()

Такой скрипт можно:

1.Запускать непосредственно

2.Запускать из других скриптов, вызывая функцию main

3.Использовать как библиотеку

	Запускаемые пакеты
	
Рассмотрим немного необычный, но все же встречающийся случай — запуск пакета.

Может показаться, что раз при загрузке пакета всегда загружается модуль __init__.py, то функцию main и условие нужно располагать в нем.

Но запуск пакетов реализован несколько иначе: при загрузке пакета интерпретатор ищет __main__.py и выполняет его как скрипт. Здесь мы не будем углубляться в причины — просто запомним, что исполняемые пакеты всегда содержат скрипт __main__.py.

Когда может понадобиться запуск пакета? Возьмем для примера один небольшой скрипт. Со временем кода в нем становилось все больше — настолько много, что этот скрипт стало совершенно невозможно поддерживать.

Представим, что мы решили превратить один модуль в пакет, содержащий модули. Но как такой пакет в дальнейшем запускать? Как раз в этом нам поможет модуль __main__.py.



	Начало работы с Poetry—

Во всех проектах профессии мы предлагаем использовать инструмент poetry — с его помощью можно управлять зависимостями. Сегодня это главный инструмент Python-разработчика.

Poetry — простой и удобный инструмент, который упрощает ведение и разработку проекта. Советуем оформлять каждый учебный эксперимент как poetry-проект, так вы быстрее привыкнете к профессиональным инструментам.

В этом уроке будем разбираться, как работать с Poetry. Пойдем по следующим шагам:


	Как установить Poetry
Poetry написан на Python, но это не обычная Python-программа, которую устанавливают с помощью pip install. Во вводном разделе документации к Poetry вы найдете команды для установки программы в вашу операционную систему.

Когда вы установите Poetry, он станет доступен как отдельная команда в shell:

poetry --version

Poetry version …


На этом установка программы заканчивается. Перед тем, как создавать первый проект, настроим инструмент для удобной работы.

	Как настроить Poetry

Если сразу после установки запросить перечень настроек Poetry, можно увидеть следующее:

poetry config --list

cache-dir = "/…/…/.cache/pypoetry"
virtualenvs.create = true
virtualenvs.in-project = null
virtualenvs.path = "{cache-dir}/virtualenvs"  # /home/astynax/.cache/pypoetry/virtualenvs


Poetry работает с виртуальными окружениями. При этом он изначально настроен так, что у вас будет много разных версий Python. По этой причине инструмент создает виртуальные окружения для проектов в непривычном месте — обратите внимание на настройку virtualenvs.path.

Можно использовать настройки по умолчанию, но Python-разработчики обычно хранят виртуальное окружение для каждого проекта в директории проекта, а именно в поддиректории .venv.

Вспомните, как вы создавали окружения командой python3 -m venv .venv. В Poetry стоит делать так же:

poetry config virtualenvs.in-project true
Теперь у каждого poetry-проекта виртуальное окружение будет при себе. Например, так можно переносить проект с одной машины на другую — достаточно просто скопировать директорию.

Когда мы настроим Poetry, он будет готов для создания первого проекта.

	Как создать первый проект

Создадим poetry-проект с помощью команды poetry new ИМЯ. Перед запуском Poetry убедитесь, что в системе доступна команда python3.

Предположим, вы ввели команду poetry new first. Вот как будет выглядеть результат:

poetry new first

Created package first in first

cd first  # Переходим в созданную директорию
tree .

.
├── first
│   └── __init__.py
├── pyproject.toml
├── README.md
└── tests
    └── __init__.py

2 directories, 4 files

Сообщение Created package first in first означает, что в проекте first создался одноименный пакет — директория first с соответствующим __init__.py. Любой poetry-проект всегда содержит хотя бы один пакет.

Кроме пакета first в проекте уже есть пакет tests. Пока он нам не нужен, но стоит знать, что у настоящих проектов всегда есть пакет с тестами.

Еще в реальном проекте у вас будет файл README.md, в котором вы будете держать описание проекта. У этого файла расширение .md — это файл формата Markdown. Это очень популярный формат разметки, даже этот урок написан на нем.

Самый важный файл в poetry-проекте — pyproject.toml. Это файл формата TOML.

Файл pyproject.toml содержит конфигурацию проекта. Информация из этого файла нужна, чтобы Poetry мог:

Управлять зависимостями проекта

Запускать код на исполнение

Запускать инструменты для разработки

Собирать дистрибутив и публиковать его на PyPI


Чем больше вы работаете с Poetry, тем лучше вы разбираетесь в публикации проектов. Постепенно вы привыкаете, что в каждом пакете должно быть описание, правильная структура, указанная версия. Мы советуем всегда оформлять проекты по этим стандартам, даже если вы не собираетесь публиковать проект в индекс.

Мы создали первый проект. Теперь нужно разобраться с pyproject.toml.

	Как работать с pyproject.toml
	
У нового проекта файл конфигурации выглядит примерно так:

[tool.poetry]
name = "first"
version = "0.1.0"
description = ""
authors = ["…"]
readme = "README.md"

[tool.poetry.dependencies]
python = "^3.10"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"


Строчки вида [tool.poetry] описывают секции с парами «ключ = значение». Большую часть ключей нельзя помещать не в свои секции. В документации можете подробнее изучить ключи и узнать, каким секциям они принадлежат.

Здесь мы рассмотрим такие строчки:

tool.poetry — описывает проект с точки зрения Poetry. Здесь хранится версия version, описание description и название проекта name

tool.poetry.dependencies — хранит список зависимостей, которые требуются для работы самого кода. Здесь всегда будет указан сам Python — без него код не запустить

Секция build-system указывает, что перед нами проект, который управляется Poetry. При этом есть и другие инструменты, чтобы управлять проектами. Для них секция build-system выглядит иначе.

Осталось разобраться с последним шагом — инициализацией виртуального окружения.

	Как инициализировать виртуальное окружение

Poetry понимает, что окружение пора создать или обновить. Такую команду можно вызвать как poetry install:

poetry install

Updating dependencies
Resolving dependencies...

Writing lock file

…

Installing the current project: first (0.1.0)


Эта команда устанавливает все зависимости в окружение в директорию .venv внутри проекта. Активируется окружение командой poetry shell, а завершается командой exit:

# Выведем список пакетов,установленных в системе
pip list
Package              Version
-------------------- ---------------
asciinema            2.2.0
attrs                22.1.0
blinker              1.4
# Тут продолжение большого списка
...

# Как видите, в системе уже стоит немало пакетов
# Поэтому мы можем столкнуться с конфликтом версий при установке нового пакета
# Чтобы этого избежать, мы и используем виртуальные окружения

# Выведем список пакетов в окружении
poetry shell
Spawning shell within /../first/.venv

pip list
# В новом окружении есть только необходимый минимум для работы Poetry
Package    Version
---------- -------
pip        22.2.2
setuptools 65.3.0
wheel      0.37.1


Зачастую активация окружения необязательна — Poetry предлагает команду run, которая исполняет программы уже изнутри окружения. Например, REPL в рамках проекта принято запускать командой poetry run python.

Так выглядит работа с Poetry. Это удобный инструмент, поэтому мы советуем пользоваться им. Оформляйте даже самые маленькие эксперименты как poetry-проекты — так вы быстрее научитесь работать с инструментом.

	Выводы
	
Poetry — удобный инструмент, который упрощает ведение и разработку проекта

Poetry устанавливают не через pip install. Для этого используются специальные команды, которые есть в документации к Poetry

Нужно, чтобы у каждого проекта виртуальное окружение было при себе. Для этого Poetry нужно предварительно настроить

В каждом пакете должно быть описание и правильная структура, а также назначена версия


	Poetry и управление зависимостями—

В этом уроке мы более подробно рассмотрим работу с зависимостями с помощью poetry. Заданием прошлого урока было создание проекта с именем hello. Примеры из этого урока будут показаны применительно к тому проекту-примеру.

	Добавление и удаление зависимостей
Добавим к проекту hello зависимость — пакет colorama. Это популярная библиотека, которая позволяет раскрасить текст в терминале. Добавим зависимости командой poetry add ИМЯ:

poetry add colorama

Using version ^0.4.5 for colorama

Updating dependencies
Resolving dependencies... (0.8s)

Writing lock file

Package operations: 1 install, 0 updates, 0 removals

  • Installing colorama (0.4.5)

Теперь взглянем на секцию tool.poetry.dependencies файла pyproject.toml. Там окажется следующее:

[tool.poetry.dependencies]
python = "^3.10"
colorama = "^0.4.5"


Как видите, colorama не только установилась в виртуальное окружение, но еще и появилась в списке зависимостей проекта. Если кто-то захочет запустить ваш код, он просто выполнит команду poetry install и получит все необходимые зависимости.

Обратите внимание на текст "^0.4.5". Он означает не только конкретную версию 0.4.5, но и все версии, совместимые с ней.

Для версии 0.4.5 совместимыми будут считаться версии вплоть до "0.5.0". Так же можно указывать конкретную версию, перечислить несколько допустимых версий или вручную указать диапазон. Все это разнообразие описано в документации.

Теперь попробуем удалить зависимости командой poetry remove ИМЯ. Из файла pyproject.toml удаляемые пакеты тоже автоматически уберутся:

poetry remove colorama

Updating dependencies
Resolving dependencies... (0.1s)

Writing lock file

Package operations: 0 installs, 0 updates, 1 removal

  • Removing colorama (0.4.5)


	Группы зависимостей
	
Многие инструменты для разработки Python-проектов написаны на Python. При этом для запуска кода они, как правило, не требуются.

Возьмем, к примеру, pytest — популярный фреймворк для написания тестов. У этого пакета много собственных зависимостей. В большом проекте подобные инструменты разработки могут занимать приличное количество места.

Проблема в том, что все эти зависимости пользователю не нужны — он же не будет запускать тесты. Тем не менее пользователь получает все зависимости вместе с программой и тратит место на хранение зависимостей.

К счастью, Poetry позволяет описать такие пакеты в виде группы зависимостей. Все созданные группы будут учтены при создании виртуального окружения, но к конечному пользователю попадут только зависимости из основной группы — то есть из [tool.poetry.dependencies].

Добавим пакет pytest к проекту hello. Укажем для него группу dev — это сокращение от слова development, так принято называть инструменты и среду разработки. Посмотрим, как это работает:

poetry add --group dev pytest

Using version ^7.1.3 for pytest

Updating dependencies
Resolving dependencies... (0.8s)

Writing lock file
...

 • Installing pytest (7.1.3)
 
 
Когда будете выполнять команду самостоятельно, обратите внимание, сколько пакетов будет установлено вместе с нужным нам pytest.

Теперь в файле pyproject.toml добавилась новая запись:

[tool.poetry.group.dev.dependencies]
pytest = "^7.1.3"


В итоге мы можем запустить pytest. Только не забывайте писать poetry run pytest вместо pytest — программа установлена в виртуальное окружение и снаружи не видна. Попробуем запустить:

poetry run pytest

# Пока pytest не запустил тесты,
# потому что мы же еще не написали их

====== test session starts ========
platform linux -- Python 3.10.4, ...
rootdir: /.../first
collected 0 items

====== no tests ran in 0.00s ======


Команда poetry run запускает не только команды из виртуального окружения — она запускает любые программы в контексте виртуального окружения. Например, с помощью системной программы which можно узнать, где находится исполняемый файл pytest:

poetry run which pytest

/../hello/.venv/bin/pytest
Теперь попробуем удалить зависимость. Для этого надо указать ее группу:

poetry remove --group dev pytest
Updating dependencies
Resolving dependencies... (0.1s)

Writing lock file
...
  • Removing pytest (7.1.3)
  
  
	Обновление зависимостей
	
Для обновления всех зависимостей нужно выполнить команду poetry update, а чтобы выполнить обновление конкретной зависимости — poetry update ИМЯ.

Зависимости обновятся в соответствии с указанными диапазонами.


	Lock-файл
	
На предыдущем шаге каждая новая установка зависимостей приводила сначала к созданию, а потом и обновлению lock-файла poetry.lock.

Обсудим этот файл подробнее. Как мы уже обсуждали, в файле pyproject.toml указываются зависимости. При этом у каждой зависимости могут быть свои собственные зависимости, которые также обновляются и так до бесконечности.

Зависимости зависимостей называются транзитивными, и с ними все не просто. Система зависимостей может быть очень запутанной. Для такой ситуации придумали специальный термин — «ад зависимостей» или dependency hell.

Проблема заключается в том, что мы никак не фиксируем версии транзитивных зависимостей.

 Представим такой пример:

В нашем проекте есть зависимый пакет A с зафиксированной версией 1.3.2
У зависимости А есть зависимый пакет B с версией *
В такой ситуации и без lock-файла команда poetry install поставила бы:

Для A — указанную версию
Для B — последнюю доступную версию из репозитория
Другими словами, выбор версии не детерминирован. Если автор обновит B и нарушит обратную совместимость, то пакет А перестанет работать — весь проект просто сломается.

Можно вручную отслеживать зависимости всех зависимостей и явно прописывать их версии в pyproject.toml. Но такой способ вряд ли сработает, потому что пакеты постоянно обновляются и меняются. Еще отслеживать вручную сложно, потому что связей слишком много — даже в проекте с пятью зависимостями будут сотни транзитивных зависимостей.

Другой выход — требовать, чтобы создатели всех библиотек всегда указывали версии. Этот вариант тоже не сработает, на этот раз из-за человеческого фактора.

Есть одно решение, которое точно сработает — это lock-файл. По сути это автоматизированное отслеживание зависимостей. Содержимое lock-файла выглядит примерно так:

[[package]]
name = "colorama"
version = "0.4.5"
description = "Cross-platform colored terminal text."
category = "main"
optional = false
python-versions = ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*"

[metadata]
lock-version = "1.1"
python-versions = "^3.10"
content-hash = "a07e5731d39f80ad23e37e53ffb7d54de3b1534e6306267399f3b25fcce783ad"

[metadata.files]
colorama = [
    {file = "colorama-0.4.5-py2.py3-none-any.whl", hash = "sha256:854bf444933e37f5824ae7bfc1e98d5bce2ebe4160d46b5edf346a89358e99da"},
    {file = "colorama-0.4.5.tar.gz", hash = "sha256:e6c6b4334fc50988a639d9b98aa429a0b57da6e17b9a44f0451f930b6967b7a4"},
]
...


Первый запуск установки зависимостей сформирует этот файл. Туда запишутся все установленные зависимости, в том числе транзитивные с версиями и хеш-суммами.

При дальнейших запусках команда poetry install всегда ставит то, что указано в lock-файле. Это сработает, даже если удалить папку .venv или добавить новые версии пакетов в файл pyproject.toml. Повторный запуск через любой промежуток времени приведет к тому же результату. Теперь с уверенностью можно сказать — проект запустится в любое время и для любого пользователя.

Наличие lock-файла никак не влияет на поведение команды update для прямых зависимостей. Представим, что у пакета из нашего файла pyproject.toml вышла новая версия.

В этом случае Poetry уточнит, можно ли обновить его до новой версии. Если да, то загрузится новая версия, а lock-файл обновится автоматически.

Если устанавливать пакеты не хочется, то для такого есть команда poetry update --lock. Она проверит, какие из новых версий подходят под указанные в конфигурации версии и обновит только lock-файл.

	
	Poetry и скрипты—

Когда вы разрабатываете программу для конечного пользователя, вам нужно закладывать в код точки входа и готовить модули или пакеты к запуску.

Но даже если вы все сделаете правильно, пользователю все равно придется писать длинную команду python3 -m ПОЛНОЕ_ИМЯ_МОДУЛЯ.

Чтобы упростить этот момент, разработчики оформляют свои пакеты так, чтобы пользователи могли вводить короткие команды. В Poetry такие описываемые команды называются скриптами.

Точка входа в проекте-примере
Точкой входа в программу может служить любая функция, расположенная в любом модуле. Чтобы поддерживать порядок в проекте, разместим точку входа в модуле hello.scripts.say_hello:


tree hello

hello/
├── __init__.py
└── scripts
    ├── __init__.py
    └── say_hello.py

cat hello/scripts/say_hello.py

def main():
    print("Hello!")


if __name__ == '__main__':
    main()
    
    
Проверяем, что точка входа работает при указании длинной команды:

poetry run python -m hello.scripts.say_hello

Hello!


Обычно вся сложная логика размещается где-то в библиотечном коде — в пакете hello в нашем случае. А вот в скрипты выносятся только небольшие куски кода, необходимые для запуска.

А теперь представим, что вы написали какой-то важный код в одном из модулей пакета scripts и хотите его импортировать в другие места. В этом случае стоит остановиться и подумать, а должен ли этот код вообще находиться в скрипте. Проще говоря, скрипты могут импортировать что-то из библиотеки, но не наоборот.

	Описание скриптов в файле конфигурации
	
Теперь мы знаем, что такое скрипт — осталось научиться их писать.

Открываем файл pyproject.toml и находим секцию tool.poetry.dependencies. Сразу после нее добавляем новую секцию tool.poetry.scripts следующего вида:

[tool.poetry.scripts]
say-hello = "hello.scripts.say_hello:main"
Разберем, как устроена пара «ключ-значение»:

Ключ — это имя будущей короткой команды
Значение — полное имя модуля, двоеточие и имя объявленной функции
Обратите внимание, что команда называется say-hello, а модуль — say_hello. Дело в том, что сложносоставные имена команд принято называть через дефис, но модули Python не могут содержать этот символ в имени. Поэтому в этом случае дефис заменен на подчеркивание.

Еще не забывайте, что hello.scripts.say_hello — это полное имя модуля, которое на первый взгляд выглядит как путь hello/scripts/say_hello.py. Если вы случайно укажете путь к файлу вместо имени модуля или забудете указать имя функции, то вызов короткой команды завершится с ошибкой.

Если все описано верно, то Poetry позволит вызывать вновь объявленную короткую команду привычным способом:

poetry run say-hello

Hello!

	
	
	Сборка дистрибутива пакета с помощью Poetry—

Когда ваш проект дорастет до того состояния, когда им можно будет с кем-то поделиться, наступит время собрать код. Собранный дистрибутив уже не потребует Poetry — программа запустится и без него.

На этом этапе нам снова поможет Poetry. В этом уроке мы разберемся, как собрать и установить дистрибутив.

	Сборка и установка дистрибутива
	
Обычно poetry-проекты практически сразу пригодны к сборке их дистрибутивов. Есть некоторые особые случаи, требующие дополнительных действий по настройке. Но здесь мы не будем рассматривать их подробно — эти знания пригождаются достаточно редко.

Простой проект можно собрать командой poetry build:

poetry build

Building hello (0.1.0)
  - Building sdist
  - Built hello-0.1.0.tar.gz
  - Building wheel
  - Built hello-0.1.0-py3-none-any.whl
  
Выполним эту команду в корневой директории проекта. После этого там появится директория dist/ с двумя файлами с разными расширениями.

Сначала рассмотрим файл с расширением .whl — это сокращение от слова wheel («колесо»). Этот файл уже пригоден к установке с помощью pip. Установим его в окружение пользователя:

python3 -m pip install --user dist/hello-0.1.0-py3-none-any.whl

Processing ./dist/hello-0.1.0-py3-none-any.whl
Installing collected packages: hello
Successfully installed hello-0.1.0

Если для проекта описаны какие-то скрипты, то они будут доступны в виде команд. Например, так работает say-hello в нашем случае:

say-hello

Hello!

	Установка пакета без сборки дистрибутива
	
Часто во время работы над кодом хочется быстро и без лишних усилий попробовать проект в деле.

Попробуем запустить программу без создания дистрибутива. Чтобы это сделать, укажем путь до директории проекта в качестве имени пакета в команде pip install:

python3 -m pip install .

Processing /.../hello
  Installing build dependencies ... done
  Getting requirements to build wheel ... done
    Preparing wheel metadata ... done
Building wheels for collected packages: hello
  Building wheel for hello (PEP 517) ... done
  Created wheel for hello: filename=hello-0.1.0-py3-none-any.whl size=1671
...
Successfully built hello
Installing collected packages: hello
Successfully installed hello-0.1.0

say-hello

Hello!


В коде выше мы использовали . — напоминаем, что она означает текущую директорию.

	Установка poetry-проектов из GitHub

Ранее в этом курсе мы уже говорили, что c помощью pip можно устанавливать пакеты напрямую из GitHub. Так вот, эта возможность доступна и для poetry-проектов. Для установки необходимо выполнить команду pip install git+ со ссылкой на репозиторий:

pip install git+https://github.com/<username>/<project-name>
Однако стоит иметь в виду, что pip относительно недавно научился понимать pyproject.toml. Поэтому советуем периодически обновлять pip с помощью команды pip install --user --upgrade pip.




	Линтинг
	
У кода есть множество разных характеристик, по которым можно судить, насколько хорошо он написан. Среди них есть одна базовая, с которой начинают все разработчики — это стиль написания.

Сравните два варианта оформления кода:

## Без форматирования
def  find_sum(a,b):
  c = a+b; return c

## С форматированием
def find_sum(a, b):
  sum = a + b
  return sum
 
Второй вариант читается значительно проще. Чем больше будет кода, тем больше будет различий. Хороший стиль кодирования — базовое требование к коду в коммерческой разработке, потому что он упрощает командную разработку. В одном проекте может работать несколько десятков программистов. Важно, чтобы им было легко читать код друг друга, не спотыкаясь о неправильное форматирование.

Для отслеживания подобных ситуаций существуют линтеры — особый класс программ. Линтеры содержат большое количество правил, по которым они могут выдать рекомендации по коду. Другими словами, они подсказывают, как стоит писать код, а как — не стоит. Более того, часто линтеры расширяются плагинами под конкретные фреймворки, что позволяет отслеживать специфичные ошибки и давать рекомендации по кодированию в этих фреймворках.

В Python особой популярностью пользуется линтер flake8. Количество правил, по которым он проверяет код, исчисляется десятками. Посмотрите на этот небольшой участок кода:

from math import sqrt


def sum(a, b):
    c = 5
    return a + b
С точки зрения форматирования здесь все хорошо, а что скажет линтер flake8?

Он выдаст два предупреждения:

F401 'math.sqrt' imported but unused. Модуль импортируется, но не используется — либо он не нужен, либо в коде есть ошибка

F841 local variable 'c' is assigned to but never used. Переменная не используется — либо она не нужна, либо в коде ошибка


Ссылки выше ведут на страницы конкретных правил. Там подробно объясняется, почему так код писать не нужно. Изучать правила flake8 очень полезно, они прививают хорошие практики написания кода.

	Установка и настройка flake8
	
Линтер flake8 устанавливается как dev зависимость прямо в проект:

poetry add --group=dev flake8
После установки его можно настроить под набор ваших правил и ограничений. Для этого нужно создать файл конфигурации setup.cfg, который нужно добавить в репозиторий. Ниже пример такого файла, который используется для настройки линтера в наших практиках:

[flake8]
accept-encodings = utf-8
max-complexity = 6
statistics = False
max-line-length = 80
enable-extensions = G
isort-show-traceback = True

exclude = .venv,dist,build

per-file-ignores =
  # init modules can contain the local imports, logic, unused imports
  __init__.py: F401

[isort]
multi_line_output = 3
include_trailing_comma = true
default_section = FIRSTPARTY
line_length = 80

Выше настраивается максимальная сложность функций, максимальная длина строчки кода и другие параметры. Так же мы можем указать, какие файлы не нужно проверять линтером или какие правила можно игнорировать. Список всех опций вы можете изучить в документации.

И последний шаг — запуск flake8:

# Обратите внимание на точку
# Это указание текущей директории и всех поддиректорий

poetry run flake8 .

Если ошибок нет, то flake8 молча завершит свою работу. Если ошибки есть, линтер выведет список с указанием того, что нужно поправить.

















