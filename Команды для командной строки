cd - это change directory эта команда меняет рабочую директорию
cd / - это смена директории по абсолютному пути, без слеша по относительному
cd .. поднимает на уровень выше
ls выводит список файлов и папок в рабочей директории
ls -a выводит список файлов и папок, включая скрытые
ls -l выводит доп.информацию по каждому файлу
-l и -a это опции, их можно комбинировать, например ls -al  или ls -la выводит все файлы, включая скрытые и выводит доп. инфо.

Опции обычно имеют две версии написания - длинную и короткую
короткие обычно пишутся с одним дефисом "-" и используются для команд в терминале
длинные обычно пишутся с двумя дефисами "--" и используются в скриптах, где нужна понятность и читаемость введенных команд

Документацию по команде можно посмотреть через команду man

stat выводит информацию о файле или директории

cat выводит текст выбранного файла 

head и tail показывают соответственно первые и последнии 10 строк из файла
можно менять кооличество выводимых строк через аргумент -n
например tail 5 -n name_file выведет последние 5 строк соответствующего файла

less пейджер для простмотра файла,

Команды для в less:	Выход — q
			Вперед на страницу — f
			Назад на страницу — b
			Поиск введенного текста — вводим /, печатаем текст и нажимаем Enter
			Переход к следующему совпадению — n
			Переход к предыдущему совпадению — N
			
grep сокращение от global regular expression print 
grep эта утилита выполняет поиск определенного текста по файлу и файлам
 SYNOPSIS
       grep [OPTIONS] PATTERN [FILE...]
       grep [OPTIONS] [-e PATTERN]...  [-f FILE]...  [FILE...]
Рассмотрим этот пример подробнее:
PATTERN — это то, что мы хотим найти. Это может быть конкретная строчка или определенный шаблон с регулярными выражениями
FILE — путь до файла, в котором нужно искать

Количество отображаемых строк до искомой строки — -B или --before-context
Количество отображаемых строк после искомой — -A или --after-context
Количество отображаемых строк до и после искомой строки — -C или --context

-r указывает, что надо искать внутри директории, при этом поиск проводится и внутри поддиректорий, а также следует указывать директорию, а не файл
При таком поиске в выводе указывается файл, в котором была найдена строка. Если добавить опцию n, то дополнительно отобразится номер строки:

Редактирование файлов
nano - простенький текстовый редактор, но не подходит для больших проектов.
'Этот текст был написан через nano'

vim сокращение от Vi Improved
Если вы не знаете команд, то лучше ничего не трогать, иначе на экране начнется хаос. Обычное редактирование текста выполняется в режиме ввода — INSERT. Попасть в него можно с помощью клавиши i. Для выхода в режим команд достаточно нажать Esc или комбинацию Ctrl + [.

Всего у Vim есть четыре основных режима работы:

Командный режим — это режим по умолчанию. В нем можно перемещаться по файлу, вносить изменения с помощью комбинаций клавиш, удалять и искать текст
Режим вставки — это режим ввода текста с клавиатуры. Здесь все работает так, как вы привыкли это делать в обычных редакторах
Визуальный режим — выделение произвольных участков текста
Режим командной строки — собственная командная строка для редактора текста, из которой можно выполнять множество разнообразных команд
'А этот текст был написан уже в vim'
Говорят, что самое сложное в Vim — это выйти, поэтому подготовимся заранее. Обсудим, как выйти из Vim:

Убедитесь, что вы находитесь в командном режиме. На всякий случай нажмите Esc или комбинацию Ctrl + [
Затем наберите : (символ "двоеточие") — эта команда переведет вас в режим командной строки
В конце введите q! и нажмите Enter
Так вы выйдете из Vim без сохранения изменений. Если набрать :wq, то перед выходом сохранятся все изменения. Если вы хотите просто сохраниться без выхода, то наберите :w.


Например, вывод любой команды в bash можно не выводить на экран, а записать в файл:
ls -la > output
Запустив эту команду, вы не увидите на экране ничего нового. Зато в текущей директории появится файл output

Операция, которую мы сделали выше, называется перенаправление потоков.
Символ > означает, что нужно взять вывод из команды слева и отправить его в файл, указанный справа. Этот символ > всегда перезаписывает файл.
Такое перенаправление работает с абсолютно любой командой, которая выводит результаты своей работы в консоль

Если нужно не перезаписывать, а добавлять, то используйте >>.
Для экспериментов с выводом удобно использовать встроенную команду echo. Она принимает на вход строчку и выдает ее в STDOUT, который уже можно перенаправлять

В *nix-системах встроена утилита wc (сокращение от word count). Она умеет считать количество слов, строк или символов в файле. Когда мы говорим о файле, то в *nix-системах это почти всегда означает, что данные можно передать и в стандартный поток ввода:

 Флаг l (буква l, а не цифра 1) указывает, что надо считать количество строк
wc -l < result # Содержимое файла result отправляем в стандартный ввод команды wc

Выглядит довольно логично — стрелка меняет свое направление в другую сторону и содержимое файла отправляется в поток STDIN запускаемой программы wc.

Теперь объединим перенаправление ввода и вывода:

wc -l < result > output # Содержимое файла result отправляем в стандартный ввод команды wc, а вывод направляем в файл output

cat output # С помощью команды cat читаем файл output
2

Перенаправление STDERR в STDOUT
Существуют следующие стандартные потоки ввода и вывода:

STDIN — 0
STDOUT — 1
STDERR — 2
Первый способ — перенаправить STDERR в STDOUT или отправить оба потока в файл.

Часто стандартный поток ошибок объединяют со стандартным потоком вывода, чтобы можно было обрабатывать ошибки и результат выполнения вместе:

# Сначала STDOUT перенаправляется в файл output, затем STDERR перенаправляется в STDOUT, запись в файл продолжается
ls lala > output 2>&1
cat output # С помощью команды cat читаем содержимое файла output

ls: cannot access 'lala': No such file or directory # Содержимое файла output в окне терминала
В примере выше обратите внимание на & после символа перенаправления >. По правилам синтаксиса символ & нужно ставить, чтобы указать поток, в который осуществляется перенаправление.

В примере ниже 2>&1 написано перед > output. Это не будет работать, потому что когда интерпретатор прочитает 2>&1, он еще не будет знать, куда перенаправлен стандартный поток вывода. Поэтому потоки ошибок и вывода не будут объединены:

ls lala 2>&1 > output

ls: cannot access 'lala': No such file or directory # Вывод в окне терминала
Перенаправление потока STDERR бывает полезно само по себе, без вывода в файл:

#  STDERR просто перенаправляется в другой поток (STDOUT)
cd lala 2>&1

-bash: cd: lala: No such file or directory



Перенаправление конкретного потока в файл
Чтобы перенаправить конкретный поток, нужно указать его номер перед >:

#  Так можно сразу перенаправить STDERR в файл
cd lala 2> output
cat output

-bash: cd: lala: No such file or directory
Перенаправление обоих потоков в файл
Этот вариант используется чаще всего. Он помогает проводить отладку и подсказывает, почему вообще возникла та или иная ошибка:

# Оба потока (STDERR и STDOUT) перенаправляются в файл
cd lala &> output
cat output

-bash: cd: lala: No such file or directory


Пайплайн

Вы уже знаете, что у одного процесса есть вход, а у другого — выход. При этом их можно подменять. Логично предположить, что их можно и соединить. Этот подход носит название пайплайн (от англ. pipeline)

grep alias .bashrc | grep color

# enable color support of handy aliases
alias grep='grep --color=auto'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'
Обратите внимание на | — этот символ называется пайп. Он указывает, что командная оболочка должна взять поток STDOUT одного процесса и соединить его с потоком STDIN другого процесса.


Запись grep alias .bashrc | grep color можно изменить, используя перенаправление. Так она станет проще для модификации:

cat .bashrc | grep alias | grep color
В примере выше файл читается катом и отправляется в поток STDIN грепа.

Еще один пример:
~$ cat source                                                                                                           
Snoop Dog                                                                                                               
Doggy cupcakes                                                                                                          
Tom cat                                                                                                                 
Reservoir Dogs                                                                                                          
Jerry mouse                                                                                                             
Dog                                                                                                                     
Dog                                                                                                                     
~$                                                                                                                      
cat source | grep Dog | uniq | sort                                                     
Dog                                                                                                                     
Doggy cupcakes                                                                                                          
Reservoir Dogs                                                                                                          
Snoop Dog                

cat source | grep Dog | uniq | sort
Посмотрим, как этот пример работает по шагам:

Читается файл source
Грепаются входные данные по подстроке Dog
Убираются дубли (в исходном файле две одинаковых строки Dog)
Сортируются входные данные и выводятся на экран


	 Манипулирование файловой структурой

	Основные команды
	
Для создания файлов принято использовать утилиту touch. Основная задача этой утилиты — поменять время последнего доступа к файлу, но она обладает побочным эффектом.

Если файла не существует, то он будет создан — именно поэтому ее используют для создания файлов, хотя это не основное предназначение:

# В текущей директории создается пустой файл
touch empty-file

Удалить файл можно командой rm (сокращение от remove):

rm empty-file

В *nix-системах не существует понятия «переименовать файл». Переименование всегда равносильно перемещению, которое выполняется командой mv (move):

touch file
mv file renamed-file

Для копирования файлов и директорий используется утилита cp (copy).

У этой утилиты два аргумента:

Имя источника (откуда копируем)
Имя приемника (куда копируем)
Посмотрим, как эта утилита работает на практике:

cp renamed-file renamed-file-copy

Для копирования директории нужно добавить флаг -r (recursive).

Утилиты для работы с директориями частично отличаются. Создание директории выполняется командой mkdir (make directory):

mkdir my-dir

По умолчанию эта команда не создает вложенных директорий:

mkdir one/two/three
mkdir: cannot create directory ‘one/two/three’: No such file or directory

В такой ситуации придется создавать каждую директорию отдельно. Но есть и другой способ — воспользоваться флагом -p (--parents), который создает директории рекурсивно:

mkdir -p one/two/three

Удаление директорий выполняется той же командой, что и удаление файлов, но без флагов оно выдает предупреждение:

rm my-dir/
rm: cannot remove 'my-dir/': Is a directory

Чтобы не было ошибки, нужно добавить флаг -r (recursion). Он включает режим рекурсивного удаления содержимого директорий. Другими словами, идет просмотр содержимого во всех вложенных директориях и поддиректориях до самого конца:

rm -r my-dir

Теперь представим такую ситуацию: внутри директории содержатся файлы или директории с ограниченными правами доступа, например, доступные только для чтения. В таком случае команда rm начнет задавать вопрос по каждому из них, нужно ли удалять файл.

Если вы точно уверены, что удалить нужно все, добавьте флаг -f (--force). Этот флаг позволяет игнорировать несуществующие файлы и не запрашивать подтверждение на удаление. В таком случае rm удалит всю директорию без вопросов:

rm -rf one


		Переменные окружения
		
Переменные окружения похожи на переменные в языках программирования. Они существуют в рамках запущенной сессии командной оболочки, то есть, переменные пропадут, когда терминал закроется. Они подгружаются туда во время его инициализации, хотя это не единственный путь их появления.

Посмотреть установленные переменные можно командой env (environment).

Основное предназначение переменных окружения — конфигурирование системы и программ. Их удобство заключается в универсальности. Кроме того, они помогают отвязать нас от способа появления этих значений в системе.

Существует некоторый базовый набор переменных, которые всегда устанавливаются bash при старте. Они используются большим количеством утилит и нужны для нормального функционирования системы. Одну из таких переменных мы уже знаем — это HOME:

# Для вывода переменной используется echo,
# а перед самой переменной ставится знак $
echo $HOME

/home/kirill.m

# Вокруг знака `=` не должно быть пробелов
HOME=/tmp
echo $HOME

/tmp

# Возвращаем обратно
HOME=/home/kirill.m
echo $HOME

/home/kirill.m

Особую роль среди переменных окружения играет PATH — еще одна важная переменная. Сложности с ней возникают настолько часто, что этой переменной посвящен практически целый урок впереди.


		История
		
История команд bash хранится в специальном файле .bash_history, который лежит в домашней директории пользователя. Каждый раз, когда пользователь вводит команду, она попадает именно в этот файл. Запись происходит при завершении сеанса. Этот файл ничем не отличается от остальных файлов: его можно открыть, посмотреть и даже отредактировать. За то, какое количество команд хранится в истории, отвечает переменная окружения HISTFILESIZE. Если она выставлена, то берется указанное в ней число. Если переменной нет, история не обрезается и файл .bash_history растет бесконечно:

tail .bash_history

rm -r one/
env
HOME=/tmp cd
pwd
cd
echo $HOME
export HOME=/tmp
id
exit
id

Посмотреть историю можно и более простым способом. Достаточно выполнить команду history:

history

 1  docke rps
 2  free -m
 3  docker ps
 4  docker exec -it 8678a6520641 bash
 5  ls
 6  exit
 7  docker ps
 8  docker exec -it 1209b6e5ce6b bash
 ...
 
 Эта команда выведет содержимое файла .bash_history, добавив слева номер. Если набрать history 5, то отобразятся только пять последних введенных команд. Используя номер команды в выводе history, можно выполнить повторный запуск без необходимости набирать или копировать команду из истории:

# Эта команда имела второй номер в списке выше
!2

free -m
              total        used        free      shared  buff/cache   available
Mem:           1998        1532          75          21         390         227
Swap:             0           0           0


При необходимости историю всегда можно погрепать:

history | grep export

 174  export HOME=/tmp
 183  history | grep export
 
 Последнее и самое интересное — реверсивный поиск. Если нажать комбинацию Ctrl + r, то запустится поиск по истории. Он ожидает ввода символов и сразу отображает ближайшую команду, в которой эти символы встречаются. Если найденное соответствие вас не устроило, то повторное нажатие Ctrl + r выберет следующее соответствие из истории:


	ПОЛЬЗОВАТЕЛИ
	
Команда whoami позволяет выяснить имя пользователя:

Команда ps (сокращение от process status) выводит отчет о работающих процессах. Информацию о том, какой процесс и под каким пользователем запущен, можно получить из вывода ps aux:

id - Выодит идентификатор пользователя 

Второй способ связан с просмотром одного важного файла, который выступает основным хранилищем пользователей в *nix-системах. Да, это обычный текстовый файл, как и все остальное:
Кроме имени и идентификатора, здесь указана командная оболочка по умолчанию и домашняя директория пользователя, которую можно поменять. Запись /usr/sbin/nologin говорит, что пользователь не может входить в систему. Такие пользователи нужны для запуска программ, у которых ограниченные права — естественно, входить в систему им не нужно.


В любой *nix-системе присутствует специальный пользователь — root или суперпользователь. Главная его особенность — это идентификатор со значением 0. Этот пользователь имеет особое значение и может выполнять абсолютно любые действия в системе. У пользователя root в файле /etc/passwd будет вот такая запись:

		
		Права доступа

Часто разработчики сталкиваются с ошибкой доступа:

touch /etc/myfile

touch: cannot touch '/etc/myfile': Permission denied
Она указывает, что текущий пользователь не имеет прав на создание файлов в каталоге /etc. Почему? Все дело в правах доступа, которые мы изучим в этом уроке.

Кроме имени пользователя и группы, с каждым файлом ассоциированы права доступа:

r — чтение (read)
w — запись (write)
x — исполнение (execute)

Причем эти права задаются для трех типов пользователей:

Владельца (User)
Пользователей, входящих в ту же группу (Group)
Остальных (Other) — тех, кто не попал в предыдущие две
Разберем на примере:

# Пример строчки из вывода команды ls -la
-rw-r--r-- 1 kirill.m kirill.m 3771 Aug 31  2015 .bashrc
Запись слева представляет собой один из вариантов описания прав доступа (permissions). Для удобства чтения разделим эту запись на группы символов:

- — этот символ обозначает, что перед нами файл
rw- — права первого типа (для владельца файла). Владелец может читать этот файл (r) и писать в него (w). Прочерк в конце означает, что этот файл нельзя исполнять
r-- — права второго типа (для группы владельца). В нашем случае такие права есть у тех, кто входит в группу kirill.m. Запись r-- говорит о наличии доступа только для чтения, а изменение и исполнение запрещены.
r-- — права третьей группы (все остальные). В нашем случае права совпадают со второй группой, поэтому файл доступен только для чтения
Не важно, какой файл или директорию мы смотрим — порядок прав в этой группе всегда один и тот же — чтение-запись-исполнение, а прочерк означает отсутствие этого права:

При этом удалить файл можно, только если у вас есть возможность писать в эту директорию

Домашняя директория имеет другие права:

В самом начале вместо - стоит d, которая обозначает директорию
Права для владельца — rwx, а для всех остальных — r-x. Из этого описания видно, что только пользователь может писать внутрь своей домашней директории
Что такое x в отношении директорий? Это право позволяет перемещаться в директорию и обращаться ко всем расположенным в ней файлам и каталогам. Обращаться можно при условии, что эти файлы доступны на чтение, запись или выполнение. Например, если положить доступный на чтение файл в директорию с правом x, то вы сможете прочитать этот файл. Если убрать с этой директории право x, то вы лишитесь доступа к файлу.

Но что тогда такое чтение? Здесь все более интуитивно понятно. По сути, директория — это список файлов, поэтому право на чтение позволяет прочитать этот список, а именно вывести список имен файлов, содержащихся в директории.

Но представим, что вы хотите посмотреть не простой список имен файлов, а список с дополнительной информацией — как при выводе ls -l. Тогда потребуется еще и право x, потому что в этом случае надо обращаться к файлам за их метаданными (владелец, группа, дата изменения, права и др.). В любом случае без права r вы не сможете посмотреть содержимое директории.

В статьях, книгах и руководствах иногда используется другой способ описания прав доступа: 755. Это не одно число, а три числа. Каждое из которых представляет собой группу rwx для наших типов пользователя в том же порядке: для владельца, входящих в группу и всех остальных. Число 0 означает, что нет никаких прав для данного типа пользователей

A	B	C	D
#	Permission	rwx		Binary
7	read, write and execute	rwx	111
6	read and write		rw-	110
5	read and execute	r-x	101
4	read only		r--	100
3	write and execute	-wx	011
2	write only		-w-	010
1	execute only		--x	001
Попробуем перевести несколько примеров из буквенной формы в числовую:

drwxr-xr-x соответствует 755
-rw-r--r-- соответствует 644

Однако пользователь root находится вне этой системы. Для него не имеет никакого значения наличие любых прав — суперпользователь может все.

Для изменения владельца файлов или директорий можно использовать утилиту chown. В самом простом использовании команда принимает имя пользователя и файл (или директорию) для которого нужно сменить пользователя:

chown kirill .bashrc
Для изменения прав доступа к файлам и директориям можно использовать утилиту chmod. Утилита принимает права доступа и путь к файлу. Права доступа можно записывать обоими способами. С помощью знаков + и - права добавляются или удаляются соответственно:

chmod +r file.txt
chmod 754 file.txt


Если вам интересно узнать, а где лежит исполняемый файл конкретной программы, то можно воспользоваться командой type (а еще which и whereis):

type cp

cp is /bin/cp

whereis cp

cp: /bin/cp

which cp

/bin/cp

ls -al /bin | grep cp

-rwxr-xr-x 1 root root  141528 Jan 18  2018 cp


	Менеджер версий
	
Сейчас asdf набрал достаточно большую популярность и постепенно заменяет собой все остальные менеджеры версий (технически под капотом там часто используются менеджеры, специфические для конкретных языков). У него чуть более сложная система команд из-за необходимости поддерживать множество языков, но в остальном он резко упрощает весь процесс.
# У asdf прекрасная документация, где наглядно показано, как его установить,
# и какие могут понадобится зависимости в разных системах

# Установка
git clone https://github.com/asdf-vm/asdf.git ~/.asdf --branch v0.11.1
# После этого нужно перезапустить терминал
echo '. $HOME/.asdf/asdf.sh' >> ~/.bashrc

# Активируем внесённые изменения
source ~/.bashrc

# Для работы с конкретным языком, сначала нужно подключить соответствующий плагин
# Список доступных плагинов есть на сайте проекта
asdf plugin add nodejs

# Установка языка
# Вместо nodejs нужно подставить название того плагина, с которым работаем
asdf install nodejs latest # latest означает последнюю версию указанного языка

# Установка указанной версии
asdf install nodejs 18.7.0

# Установка нужной версии языка версией по умолчанию
asdf global nodejs 18.7.0

# Показывает текущие версии для языков, установленных через asdf
asdf current
elixir         1.10.1-otp-22 (set by /Users/user/.tool-versions)
erlang         22.2.7   (set by /Users/user/.tool-versions)
nodejs         17.0.0   (set by /Users/user/.tool-versions)
php            7.4.5    (set by /Users/user/.tool-versions)
python         3.8.2 2.7.16 (set by /Users/user/.tool-versions)
ruby           2.7.0    (set by /Users/user/.tool-versions)
yarn           1.22.4   (set by /Users/user/.tool-versions)





