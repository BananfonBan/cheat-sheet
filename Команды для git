		Команды для  git
		
Git может отслеживать файлы проекта только в том случае, когда они помещены под контроль версий. Для этого нужно зайти в директорию проекта и выполнить команду инициализации git init.

Проект может быть как новый, так и уже существующий. Процесс инициализации от этого не поменяется:

# Создаем новый проект
mkdir hexlet-git

# Переходим в созданную директорию
cd hexlet-git

# Выполняем инициализацию
git init

Initialized empty Git repository in /private/tmp/hexlet-git/.git/

Команда git init создает репозиторий — директорию .git, которая содержит все необходимые для работы Git-файлы.

С помощью команды git status можно посмотреть статус репозитория:

git status

On branch main
No commits yet
nothing to commit (create/copy files and use "git add" to track)

В этом выводе указано, что репозиторий пустой (No commits yet) — в нем нет новых или измененных файлов.

Давайте попробуем добавить несколько файлов:

# Создаем файл README.md со строкой текста
echo 'Hello, Hexlet!' > README.md
echo 'Haskell Curry' > PEOPLE.md

Теперь снова смотрим на статус:

git status

# Часть вывода убрана
Untracked files:
  (use "git add <file>..." to include in what will be committed)
    PEOPLE.md
    README.md
Git увидел, что в проекте появились новые файлы, о которых ему ничего не известно. Они помечаются как неотслеживаемые файлы (untracked files).

Git не следит за изменениями в таких файлах, потому что они не добавлены в репозиторий.


Добавление в репозиторий происходит в два шага. Первым шагом выполняем команду подготовки файлов git add <путь до файла>:

# Для каждого нового или измененного файла
git add README.md
Смотрим, что произошло:

git status

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
    new file:   README.md

Untracked files:
  (use "git add <file>..." to include in what will be committed)
    PEOPLE.md


Файл README.md теперь находится в состоянии «подготовлен к коммиту» — другими словами, файл попал в индекс.

Следующий шаг — это коммит. Под этим термином понимается окончательное добавление в репозиторий, когда Git запоминает файл навсегда и следит за всеми последующими изменениями.

Во время коммита мы берем все подготовленные изменения (они могут включать любое количество файлов) и отправляем их в репозиторий как единое целое. Вот, как он выполняется:

git commit -m 'add README.md'

[main (root-commit) 3c5d976] add README.md
1 file changed, 1 insertion(+)
create mode 100644 README.md



Флаг -m означает message, то есть описание коммита. Коммит можно выполнять и без него, но тогда откроется редактор, в котором нужно будет ввести описание коммита.

Мы рекомендуем делать осмысленные описания — это хороший тон. Пример соглашения по именованию коммитов приведен в дополнительных материалах к уроку.


Со смысловой точки зрения, коммит — это какое-то логически завершенное изменение внутри проекта. Его размер бывает очень разным:

Маленьким, если мы исправляем одну опечатку в одном файле
Большим, если мы внедряем новую функциональность
Главное в коммите — его атомарность. Другими словами, он должен выполнять ровно одну задачу.

Теперь файл README.md находится внутри репозитория. Убедиться в этом можно, запустив команду git status:

git status

Untracked files:
  (use "git add <file>..." to include in what will be committed)
    PEOPLE.md
Команда git status не выводит файлы, которые добавлены в репозиторий и не содержат изменений. При этом сам файл README.md находится внутри директории hexlet-git.

Сохраненный репозиторий в любой момент можно извлечь и продолжить работу в нем с последнего добавленного коммита. Это пригодится, если мы случайно удалим или изменим локальный репозиторий так, что с ним станет невозможно работать.



	Добавим наш репозиторий на GitHub:

Зарегистрируйтесь на GitHub и создайте ssh-ключи по инструкции. SSH-ключи — это наиболее безопасный способ работы с GitHub, поэтому важно разобраться с ними
Создайте репозиторий на GitHub. Назовите его hexlet-git. Важно, чтобы репозиторий создавался пустым, поэтому не отмечайте галочки, добавляющие файлы
На странице репозитория вы увидите готовые команды для подключения созданного репозитория на GitHub к уже существующему репозиторию у вас на компьютере:


Выполните эти шаги:

# Подробнее эти команды мы разберем позже
# Вам нужна ссылка для работы с репозиторием по SSH
git remote add origin git@github.com:<ИМЯ НА ГИТХАБЕ>/hexlet-git.git
git branch -M main
git push -u origin main
Обновите страницу с репозиторием на GitHub. Изучите ее интерфейс и содержимое репозитория. Обратите внимание, что директория .git отсутствует. Почему это так, мы узнаем в одном из следующих уроков

	Как клонировать репозиторий
Репозитории на GitHub делятся на публичные и приватные. Публичный репозиторий любой человек может клонировать себе на компьютер. После клонирования он начнет работать с ним как с личным.

Единственное ограничение — он не сможет запушить изменения, так как GitHub не дает напрямую менять чужие репозитории.

Клонирование — базовая операция при работе с удаленными репозиториями. Проекты, над которыми работают программисты, всегда находятся в системах, подобных GitHub. Для работы с ними нужно клонировать репозиторий к себе на компьютер.

Клонировать репозиторий можно с помощью команды git clone. Полную команду для клонирования можно получить на странице репозитория. Для этого нажмите большую кнопку Code, перейдите на вкладку SSH и скопируйте содержимое:

git clone git@github.com:<ИМЯ НА ГИТХАБЕ>/hexlet-git.git
cd hexlet-git
ls -la

# Если эта операция проходит первый раз,
# То вы можете увидеть такое подобное сообщение
The authenticity of host github.com cannot be established. RSA key fingerprint is SHA256: хххххххххх Are you sure you want to continue connecting (yes/no/[fingerprint])? yes Warning: Permanently added github.com (RSA) to the list of known hosts.
# Наберите yes и нажмите Enter
Мы получили точную копию репозитория, который был у нас до удаления директории hexlet-git.

	Как получить изменения с GitHub
Разработчики не только отправляют свои изменения на GitHub, но и забирают их оттуда. Чаще всего это изменения, сделанные другими разработчиками проекта, но необязательно. Бывает такое, что один разработчик работает над одним проектом с разных компьютеров, на каждом из которых своя собственная копия репозитория.

В таком случае, перед началом работы нужно всегда выполнять команду git pull --rebase, которая скачивает из внешнего репозитория новые коммиты и добавляет их в локальный репозиторий.

Считается, что достаточно вызывать git pull, но это может приводить к созданию ненужных коммитов, из-за которых становится сложнее следить за историей изменений.


	После клонирования репозитория hexlet-git мы можем увидеть внутри него директорию .git и добавленные нами файлы. Посмотрим, что произойдет, если удалить один из файлов:

rm PEOPLE.md
git status

On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
    deleted:    PEOPLE.md

no changes added to commit (use "git add" and/or "git commit -a")
Git сообщает, что файл был удален, и предлагает команды для восстановления или коммита изменений.



Внутри директории проекта мы видим файлы проекта с одной стороны и директорию .git с другой.

Репозиторием является именно директория .git. Она хранит всю информацию о том, какие были изменения, а также сами изменения.

А вот все, что находится снаружи, это так называемая рабочая директория (working directory). Эти файлы извлекаются из .git в момент клонирования.

Каждый раз, когда мы производим изменения в рабочей директории, Git сравнивает измененные файлы с файлами внутри .git, то есть их состоянием на момент последнего коммита. Если есть изменения относительно последней зафиксированной версии, то Git сообщает нам об этом в выводе команды git status.

В этом очень легко убедиться, если последовать совету Git в выводе выше и восстановить удаленный файл:

git restore PEOPLE.md
git status

On branch main
Your branch is up to date with 'origin/main'.

nothing to commit, working tree clean

# Сам файл вернулся таким, каким он был на момент последнего коммита
Можно удалить все файлы в рабочей директории и потом без проблем их восстановить. Так мы достигаем важной цели — создаем возможность быстро восстановить последнюю версию кода, если внесенные изменения нас больше не устраивают.

Еще мы можем закоммитить их, если это нужно:

rm PEOPLE.md
# Любое изменение нужно добавлять в индекс
git add PEOPLE.md
git commit -m 'remove PEOPLE.md'

[main e15afd2] remove PEOPLE.md
1 file changed, 1 deletion(-)
delete mode 100644 PEOPLE.md
# Теперь этот файл пропал из рабочей директории
Обратите внимание на важную деталь. Независимо от того, удаляем мы файл, добавляем или меняем, процедура выполнения коммита не меняется. После изменений всегда делается git add, который подготавливает изменение к коммиту (а не добавляет файл). После этого выполняется коммит.

Кстати, у Git есть команда git rm, которая объединяет в себе удаление и подготовку к коммиту:

git rm PEOPLE.md
# Равносильно rm + git add


	Git diff


Анализировать изменения важно даже в небольших проектах. Прямо сейчас во время разработки этого курса изменилось несколько файлов и git status выглядит так:

git status

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
    modified:   300-working-directory/README.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
    modified:   100-intro/README.md
    modified:   250-github/README.md
    modified:   300-working-directory/README.md
    modified:   300-working-directory/spec.yml
    modified:   350-changes/README.md
Попробуем воспроизвести подобную ситуацию в нашем проекте. Выполним следующий код в репозитории hexlet-git:

echo 'new line' >> INFO.md
echo 'Hello, Hexlet! How are you?' > README.md

git status

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
    modified:   INFO.md
    modified:   README.md

no changes added to commit (use "git add" and/or "git commit -a")
Изменились оба файла. В один файл мы добавили строчку, в другом — заменили. Как теперь посмотреть эти изменения?

Для этого в Git есть команда git diff, которая показывает разницу между тем, что было и что стало:

git diff

diff --git a/INFO.md b/INFO.md
index d5225f8..40f51f1 100644
--- a/INFO.md
+++ b/INFO.md
@@ -1 +1,2 @@

 git is awesome!
+new line

diff --git a/README.md b/README.md
index ffe7ece..00fd294 100644
--- a/README.md
+++ b/README.md
@@ -1 +1 @@

-Hello, Hexlet!
+Hello, Hexlet! How are you?
Вывод команды поначалу может смутить. Здесь довольно много служебных данных, за которыми уже идут изменения.

Вывод git diff содержит не файлы целиком, а именно те строки, которые изменились — и иногда строки вокруг измененных для удобства анализа.

Слева от строк ставится:

Знак -, если строка была удалена
Знак +, если строка была добавлена
Сама команда не просто выводит на экран разницу между файлами, но и запускает пейджер — специальную программу, которая позволяет перемещаться по выводу и искать внутри него нужные данные. Для этого используются клавиши:

'f' — перемещение вниз
'b' или 'u' — перемещение вверх
'q' — или выход из режима просмотра
По умолчанию команда git diff показывает изменения только для тех модифицированных файлов, которые еще не были добавлены в индекс. Подразумевается, что добавленные в индекс файлы смотреть не нужно, ведь мы их уже подготовили к коммиту. Но лучше еще раз увидеть эти изменения и все проверить. Для этого нужно запустить команду git diff с флагом --staged:

# Выведет все изменения, сделанные в рабочей директории
# которые были добавлены в индекс
git diff --staged
В целом, git diff — команда, которую нужно обязательно запускать перед каждым коммитом. С ее помощью можно проанализировать добавляемые изменения и исправить возможные ошибки, ведь иногда программисты случайно добавляют в коммит то, что туда не должно попасть.


	Анализ истории изменений

	
Программирование — это не только написание новых программ, но и постоянный анализ уже написанного кода. Иногда код понятен и без слов — и это хороший код.

Но так происходит не всегда. Код может вызывать вопросы. Почему он написан именно так, кто его написал и когда.

Ответить на эти вопросы помогает история изменений. Хорошо сделанные коммиты имеют понятное описание, и каждый из них делает ровно одну законченную вещь — в таком случае история становится мощным инструментом для анализа кода. Именно поэтому так важно хорошо понимать философию Git и следовать лучшим практикам при работе с ним.

Git предоставляет целую пачку команд со множеством опций, позволяющих вытащить невероятное количество информации и показать все, что скрыто. С ними мы познакомимся в этом уроке.

Команда git log
Самая простая аналитика выполняется командой git log. Она показывает список всех выполненных коммитов, отсортированных по дате добавления. Сверху мы видим самые последние коммиты:

git log

# Ниже неполный вывод истории проекта

commit 5120bea3e5528c29f8d1da43731cbe895892eb6d
Author: tirion <tirion@got.com>
Date:   Thu Sep 17 18:04:19 2020 -0400

    add new content

commit e6f625cf8433c8b1f1aaed58cd2b437ec8a60f27
Author: tirion <tirion@got.com>
Date:   Thu Sep 17 16:14:09 2020 -0400

    add INFO.md

commit 273f81cf2117044f1973ea80ce1067a94bea3f80
Author: tirion <tirion@got.com>
Date:   Thu Sep 17 16:08:39 2020 -0400

    remove NEW.md

# Этот вывод показывается через пейджер
Из этого вывода мы можем узнать кто, когда и какие коммиты делал. Если коммиты оформлены хорошо, то по их описанию уже многое понятно. Оформление коммитов — отдельная тема, которую мы рассмотрим позже.

У команды git log есть полезный флаг -p, который сразу выводит диф для каждого коммита:

git log -p
# Тут все коммиты с полным дифом
# Промотать вперед — кнопка f, промотать назад — b
# Выйти из режима просмотра — q	
	
	
	Команда git show
У каждого коммита есть уникальный набор символов — идентификатор (еще говорят «хеш»). С помощью хеша можно посмотреть все изменения, сделанные в рамках одного коммита:

git show 5120bea3e5528c29f8d1da43731cbe895892eb6d
# Тут выводится диф между этим коммитом и предыдущим

diff --git a/INFO.md b/INFO.md
index d5225f8..40f51f1 100644
--- a/INFO.md
+++ b/INFO.md
@@ -1 +1,2 @@
 git is awesome!
+new line
diff --git a/README.md b/README.md
index ffe7ece..00fd294 100644
--- a/README.md
+++ b/README.md
@@ -1 +1 @@
-Hello, Hexlet!
+Hello, Hexlet! How are you?
# Здесь мы видим, что было изменено этим коммитом
Хеши коммитов в Git очень длинные, и ими бывает неудобно пользоваться. Поэтому разработчики Git добавили возможность указывать только часть хеша. Достаточно взять первые семь символов и подставить их в ту команду, которая работает с коммитами:

git show 5120bea
Чаще всего вам не придется высчитывать их самим. Большая часть команд Git выводит хеш коммита в сокращенном варианте, облегчая его использование. Такое упрощение хорошо работает, потому что даже первые семь символов будут всегда уникальными.
	
	
	Команда git blame
А что если мы не знаем коммита, но нам интересно, кто последним менял конкретную строчку в файле? Для этого подойдет команда git blame <путь до файла>. Эта команда выводит файл и рядом с каждой строчкой показывает того, кто ее менял и в каком коммите:

git blame INFO.md

e6f625cf (tirion 2020-09-17 16:14:09 -0400 1) git is awesome!
5120bea3 (tirion 2020-09-17 18:04:19 -0400 2) new line
Важно помнить, что изменение строчки — не то же самое, что ее написание. Вполне возможно, что программист исправил небольшую опечатку, а саму строчку написал кто-то до него. Имея такой вывод, уже легко пойти дальше и изучить конкретный коммит.
	
	
	Команда git grep
Команда git grep ищет совпадение с указанной строкой во всех файлах проекта. Это очень удобная команда для быстрого анализа из терминала. Она удобнее обычного grep, потому что знает про игнорирование и не смотрит в директорию .git, а еще умеет искать по истории:

git grep line

INFO.md:new line

# Флаг `i` позволяет искать без учета регистра
git grep -i hexlet

README.md:Hello, Hexlet! How are you?

# Поиск в конкретном коммите
git grep Hexlet 5120bea

# Поиск по всей истории
# Возвращаем список хешей коммитов `rev-list`
git grep Hexlet $(git rev-list --all)	


	GitHub
В простых ситуациях анализировать проект можно прямо на GitHub. Он позволяет просматривать историю коммитов, изменения в конкретном коммите и многое другое.



	Отмена изменений в рабочей директории
	
Одна из ключевых возможностей Git — это откат любых сделанных изменений буквально одной командой. Такое практически невозможно сделать без использования системы контроля версий — только если помнить все изменения наизусть. В этом уроке мы поговорим про откат изменений, которые сделаны в рабочей директории, но еще не попали в коммит.

Отдельно отметим, что откат незакоммиченных изменений безвозвратен. Не существует никакой физической возможности получить эти изменения обратно, поэтому будьте крайне осторожны.

	Неотслеживаемые файлы
Это самая простая ситуация. Представьте, что вы добавили новые файлы в репозиторий и поняли, что они вам не нужны.

В этом случае можно выполнить очистку:

mkdir one
touch two

git status

On branch main
Your branch is up to date with 'origin/main'.

# Пустые директории в Git не добавляются в принципе
# Физически директория one находится в рабочей директории,
# но при этом ее нет в Git, поэтому Git игнорирует ее
Untracked files:
  (use "git add <file>..." to include in what will be committed)
    two

# Выполняем очистку. Команда удалит все незакоммиченные изменения
# -f – force, -d – directory
git clean -fd

Removing one/
Removing two


	Измененные файлы в рабочей директории
Для отмены изменений в таких файлах используется команда git restore. Причем Git сам напоминает об этом при проверке статуса:

echo 'new text' > INFO.md
git status

On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  # Ниже написано, как отменить изменение
  (use "git restore <file>..." to discard changes in working directory)
    modified:   INFO.md

# Отменяем
git restore INFO.md


	Изменения, подготовленные к коммиту
С файлами, подготовленными к коммиту, можно поступить по-разному. Первый вариант — отменить изменения совсем, второй — отменить только индексацию, не изменяя файлы в рабочей директории. Второе полезно в том случае, если изменения нужны, но мы не хотим их коммитить сейчас:

echo 'new text' > INFO.md
git add INFO.md
git status

On branch main
Your branch is up to date with 'origin/main'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
    modified:   INFO.md
И здесь снова помогает Git. При выводе статуса он показывает нужную команду для перевода изменений в рабочую директорию:

git restore --staged INFO.md
git status

On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
    modified:   INFO.md
Теперь, если нужно, можно выполнить git restore и окончательно отменить изменения в выбранных файлах


	Отмена коммитов


Git — система, в которой не нужно бояться совершать ошибки. Можно сказать, что ошибки — это единственный способ научиться им пользоваться. В Git практически всегда есть способ восстановить или изменить любые коммиты. На крайний случай спасет повторный git clone.

Что делать, если коммит уже сделан, но он нас по каким-то причинам не устраивает? Ситуаций может быть много, и все они возникают регулярно даже у профессиональных разработчиков:

Забыли добавить в коммит нужные файлы
Изменения нужно «откатить», чтобы доработать
Изменения больше не актуальны, и их нужно удалить
Изменения были сделаны по ошибке, и их нужно отменить

По большей части Git движется «только вперед». Правильный подход при работе с ним — это создавать новое, а не изменять старое.

Все ситуации, описанные выше, можно решить новым коммитом, изменяющим код в нужном направлении. Это не только удобно, но и безопасно. Изменение истории коммитов — опасная операция, которая чревата проблемами при синхронизации с удаленными репозиториями. Об этом мы поговорим позже.

Несмотря на сказанное выше, внутри Git существуют специальные команды, позволяющие упростить отмену, либо изменение коммита. С их помощью можно сделать историю коммитов понятной, а сам процесс отката — быстрым.

	Git revert
Самая простая ситуация — отмена изменений. Фактически она сводится к созданию еще одного коммита, который выполняет изменения, противоположные тому коммиту, который отменяется

Руками создавать подобный коммит довольно сложно, поэтому в Git добавили команду, автоматизирующую откат. Эта команда называется git revert:

# Этой команде нужен идентификатор коммита
# Это коммит, которым мы удалили файл PEOPLE.md
git revert aa600a43cb164408e4ad87d216bc679d097f1a6c
# После этой команды откроется редактор, ожидающий ввода описания коммита
# Обычно сообщение revert не меняют, поэтому достаточно просто закрыть редактор
[main 65a8ef7] Revert "remove PEOPLE.md"
 1 file changed, 1 insertion(+)
 create mode 100644 PEOPLE.md
# В проект вернулся файл PEOPLE.md

git log -p

commit 65a8ef7fd56c7356dcee35c2d05b4400f4467ca8
Author: tirion <tirion@got.com>
Date:   Sat Sep 26 15:32:46 2020 -0400

    Revert "remove PEOPLE.md"

    This reverts commit aa600a43cb164408e4ad87d216bc679d097f1a6c.

diff --git a/PEOPLE.md b/PEOPLE.md
new file mode 100644
index 0000000..4b34ba8
--- /dev/null
+++ b/PEOPLE.md
@@ -0,0 +1 @@
+Haskell Curry

Команда revert может отменять не только последний коммит, но и любой другой коммит из истории проекта. Согласитесь, это очень круто. Без системы контроля версий о таком нельзя было и мечтать.

	Команда git reset
Представьте, что вам нужно удалить только что сделанный по ошибке коммит. Конечно, и в этом случае подходит git revert, но так история становится менее читаемой. Если этот коммит сделан был только сейчас и еще не отправлялся на GitHub, то лучше сделать так, как будто бы этого коммита не существовало в принципе.

Git позволяет удалять коммиты. Это опасная операция, которую нужно делать только в том случае, если речь идет про новые коммиты, которых нет ни у кого, кроме вас.

Если коммит был отправлен во внешний репозиторий, например, на GitHub, то менять историю ни в коем случае нельзя. Это сломает работу у тех, кто работает с вами над проектом.

Для удаления коммита используется команда git reset:

# Добавляем новый коммит, который мы сразу же удалим
echo 'test' >> INFO.md
git add INFO.md
git commit -m 'update INFO.md'

[main 17a77cb] update INFO.md
 1 file changed, 1 insertion(+)
 # Важно, что мы не делаем git push

git reset --hard HEAD~

HEAD is now at 65a8ef7 Revert "remove PEOPLE.md"

# Если посмотреть `git log`, то последнего коммита там больше нет

У команды git reset есть множество различных флагов и способов работы. С ее помощью можно удалять коммиты, отменять их без удаления, восстанавливать файлы из истории и так далее. Работа с ней относится к продвинутому использованию Git, но здесь мы затрагиваем только самую базу.

Флаг --hard означает полное удаление. Без него git reset отменит коммит, но не удалит его, а поместит все изменения этого коммита в рабочую директорию, так что с ними можно будет продолжить работать.

Флаг HEAD~ означает «один коммит от последнего коммита». Обратите внимание, что здесь используется знак ~ — тильда. Его легко перепутать с дефисом -. Если бы мы хотели удалить два последних коммита, то могли бы написать HEAD~2:


HEAD (переводится как «голова») — так обозначается последний сделанный коммит. Подробнее эту терминологию мы разберем в уроке, посвященном внутреннему устройству Git.

Если не указывать флаг --hard, то по умолчанию подразумевается флаг --mixed. В таком варианте git reset отправляет изменения последнего коммита в рабочую директорию. Затем их можно исправить или отменить и выполнить новый коммит:

echo 'no code no pain' > README.md
git add README.md
git commit -m 'update README.md'

[main f85e3a6] update README.md
 1 file changed, 1 insertion(+)

# Теперь откатываем последний коммит
git reset HEAD~

Unstaged changes after reset:
M   README.md

git status

On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
    modified:   README.md
Последнего коммита больше не существует. При этом сделанные в нем изменения не пропали. Они находятся в рабочей директории для дальнейшей доработки.


	Изменение последнего коммита—

Крайне часто разработчики делают коммит и сразу понимают, что забыли добавить часть файлов через git add. Оставшуюся часть изменений можно дослать следующим коммитом.

Есть еще один способ. Если изменения еще не были отправлены во внешнюю систему, можно добавить изменения в текущий коммит. Для этого во время коммита добавляется флаг --amend:

echo 'experiment with amend' >> INFO.md
echo 'experiment with amend' >> README.md
git add INFO.md
# Забыли сделать подготовку README.md к коммиту
git commit -m 'add content to INFO.md and README.md'

[main 256de25] add content to INFO.md and README.md
 1 file changed, 1 insertion(+)

git status

On branch main
Your branch is ahead of 'origin/main' by 1 commit.
  (use "git push" to publish your local commits)

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
    modified:   README.md

# Увидели, что забыли добавить файл
# Добавляем

git add README.md
git commit --amend
# После этой команды откроется редактор, ожидающий ввода описания коммита
# Здесь можно поменять сообщение или выйти из редактора, оставив старое

[main d96151a] add content to INFO.md and README.md
 Date: Sat Sep 26 16:02:07 2020 -0400
 2 files changed, 2 insertions(+)

git status

On branch main
Your branch is ahead of 'origin/main' by 1 commit.
  (use "git push" to publish your local commits)

nothing to commit, working tree clean
В реальности --amend не добавляет изменения в существующий коммит. Этот флаг приводит к откату коммита через git reset и выполнению нового коммита с новыми данными. Поэтому мы и видим ровно один коммит, хотя команда git commit выполнялась два раза (первый раз — когда сделали ошибочный коммит).

Чтобы не открывался редактор для ввода описания коммита к команде git commit --amend можно добавить опцию --no-edit. В этом случае описание коммита не изменится:


	Индекс—

Индекс в Git — это специальная промежуточная область, в которой хранятся изменения файлов на пути от рабочей директории до репозитория. При выполнении коммита в него попадают только те изменения, которые были добавлены в индекс. В этом уроке вы узнаете, зачем нужен индекс и как он работает.

Понятие индекса в Git появилось неслучайно. Даже когда разработчик работает над одной задачей, по пути он натыкается на разные проблемы в коде:

Ошибки
Код с плохим оформлением
Фрагменты, которые нужно будет исправить под новые требования

В большинстве ситуаций совершенно нормально исправлять эти недочеты, что все и делают. В итоге в рабочей директории появляется множество разных исправлений. Частично они относятся к выполняемой задаче, а частично — содержат множественные исправления, напрямую не связанные с основными изменениями. В чем здесь проблема?

Представим, что мы сделали ровно один коммит, в который включили и основную задачу, и дополнительные исправления. В таком случае, мы получаем несколько неприятных побочных эффектов.

Во-первых, становится сложнее смотреть историю. Коммит начинает содержать совершенно несвязанные изменения, которые отвлекают во время проверки чужого кода:

# Обычно в таких коммитах встречается условие И в описании
# Это показатель того, что в рамках одного коммита сделано несколько изменений
git commit -m 'add new feature and fix something'
Во-вторых, откат коммита по любым причинам приведет к тому, что откатятся правки, которые все равно нужно будет делать.

Именно здесь помогает индекс. Если он есть, мы можем не переживать, как сформируется коммит.

Стандартный способ работы с индексом — это добавление или изменение файлов и последующий коммит:

git add somefile
git commit -m 'add somefile'
Если речь идет про один-два файла, которые нужно закоммитить прямо сейчас, то можно сделать проще. Этот подход работает только с уже отслеживаемыми файлами:

echo 'new data' >> INFO.md
# Не нужно явно вызывать команду `git add`
git commit INFO.md -m 'update INFO.md'
Иногда бывает наоборот — мы исправили много файлов и хотим добавить их в коммит сразу все. Тогда поможет точка:

# Добавляет абсолютно все изменения рабочей директории в индекс
git add .
Команда выше очень опасна. С ее помощью крайне легко закоммитить много лишнего, особенно если перед коммитом не посмотреть git diff --staged.

Ну и совсем страшная, но полезная команда — это коммит с одновременным добавлением всего в индекс:

# Флаг -a автоматически добавляет все изменения рабочей директории в индекс
git commit -am 'do something'
С другой стороны, нередко разные изменения делаются в одних и тех же файлах. То есть изменения в этих файлах по-хорошему должны находиться в разных коммитах.

И даже такое можно сделать с помощью Git. Для этого подходит команда git add -i, которая показывает измененные куски файлов и спрашивает, что с ними сделать


	Перемещение по истории


Git позволяет не только просматривать историю. Еще мы можем перемещаться по истории, загружая в рабочую директорию состояние кода на момент выполнения любого коммита. В этом уроке мы изучим, как перемещаться по истории с помощью команды git checkout.

Для начала воспользуемся командой git log:

# Показывает сокращенный вывод
git log --oneline

fc74e2d update README.md
65a8ef7 Revert "remove PEOPLE.md"
5120bea add new content
e6f625c add INFO.md
273f81c remove NEW.md
aa600a4 remove PEOPLE.md
fe9893b add NEW.md
3ce3c02 add PEOPLE.md
3c5d976 add README.md

Переключимся на момент, когда был выполнен коммит с сообщением add INFO.md. Для этого используем команду git checkout <хеш коммита>:

git checkout e6f625c

Note: switching to 'e6f625c'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

Or undo this operation with:

  git switch 

Выполните команду выше и изучите рабочую директорию. Обратите внимание, что хеш вашего коммита может отличаться. Вы увидите, что пропала часть изменений из-за возврата в прошлое. Сами изменения никуда не делись, и мы снова можем вернуться на последний коммит следующей командой:

# Позже мы поговорим, что такое main
git checkout main

Переключившись в нужный коммит, можно не только изучить содержимое репозитория. Еще мы можем забрать какие-то изменения, которые были удалены, но снова понадобились для работы. Для этого достаточно их скопировать, переключиться на последний коммит и вставить в нужный файл.

	Команда git branch

Переключение по коммитам отражается только на содержимом рабочей директории. Больше нигде не видно, где мы находимся. Из-за этого немало программистов забывают, где они находятся. Они начинают работать и очень удивляются, когда не получается выполнить коммит.

Самый простой способ узнать место нахождения — вызвать команду git branch. В обычной ситуации, когда мы находимся на последнем коммите, Git покажет такой вывод:

git branch

# Позже мы поговорим, что такое main
* main
Но если прямо сейчас загружен коммит из прошлого, то вывод станет таким:

* (HEAD detached at e6f625c)
  main
Такой способ проверки текущего местоположения требует постоянного внимания. Нужно не забывать его использовать. Конечно же, все забывают это делать, поэтому гораздо надежнее и удобнее вывести текущее местоположение прямо в командной строке. Например, так:

# Если на последнем коммите
hexlet-git git:(main)

# Если на коммите из прошлого
hexlet-git git:(e6f625c)

Именно так делают большинство профессиональных разработчиков. Как добиться такого вывода? Ответ на этот вопрос зависит от используемого командного интерпретатора:

В Bash вывод местоположения происходит благодаря редактированию переменной окружения $PS1, подробнее об этом вы можете почитать по ссылке в дополнительных материалах.




	Понимание Git—

Обилие команд и возможностей могут повергнуть в ужас любого, кто только начинает изучать Git. Git — это комбайн с невероятным количеством фич. Но надо ли знать их все? И как их запомнить? Как вообще научиться эффективно его использовать? В этом уроке мы ответим на эти вопросы.

Правда состоит в том, что почти никто не знает Git до конца. Разработчики регулярно открывают внутри него что-то новое, а еще постоянно гуглят его команды или смотрят документацию. Единственный способ изучить Git — постоянно использовать его. Причем наибольший эффект достигается при работе с Git в команде. Одиночная разработка в этом смысле сильно уступает, так как не затрагивает многих сложных ситуаций, возникающих только при совместной работе над одним и тем же кодом.

С другой стороны, чтобы освоить Git, нужно понять, как он устроен и на каких идеях базируется. После этого вы осознаете, что подавляющее большинство команд — это всего лишь обертки над очень простой концепцией.

Для начала давайте выведем коммиты нашего проекта hexlet-git в специальном виде, который активируется опцией --graph:

git log --graph

# Неполный вывод, чтобы не отвлекаться от сути
* commit e7bb5e51f96e572084f6c04ba3312e32ce6b8c0f (HEAD -> main, origin/main, origin/HEAD)
|
|     update README.md
|
* commit 65a8ef7fd56c7356dcee35c2d05b4400f4467ca8
|
|     Revert "remove PEOPLE.md"
|
|     This reverts commit aa600a43cb164408e4ad87d216bc679d097f1a6c.
|
* commit 5120bea3e5528c29f8d1da43731cbe895892eb6d
|
|     add new content
|
* commit e6f625cf8433c8b1f1aaed58cd2b437ec8a60f27
|
|     add INFO.md
|
* commit 273f81cf2117044f1973ea80ce1067a94bea3f80
|
|     remove NEW.md

Обратите внимание на полоску слева. Она отражает связи между коммитами. Каждый новый коммит базируется на коде предыдущего коммита. С точки зрения информатики коммиты выстраиваются в так называемый односвязный список. В таком списке каждый элемент ссылается на предыдущий. Последний элемент при этом называется головой списка (head по-английски).

В Git элементы списка — это сами коммиты. Как и в односвязном списке, новый коммит — это элемент, который имеет ссылку на предыдущий коммит. Предыдущий коммит ссылается на свой предыдущий, и так далее до первого коммита, который никуда не ссылается.

Понятие «голова списка» (HEAD) в Git присутствует явно и активно используется для разных операций. Например, удаление последнего коммита выглядит так:

# HEAD~1 означает: взять голову и удалить один коммит, начиная от нее
# То есть мы удаляем только последний коммит
git reset --hard HEAD~1
Сам список коммитов тоже имеет название. Вы его уже видели — это main. В терминологии Git такой список называется веткой (branch). Именно поэтому команда для показа текущего местоположения в истории называется git branch:

git branch

* main


Строго говоря, ветка в Git — это просто подвижный указатель на один из коммитов. При каждом новом коммите указатель сдвигается вперед автоматически.

Основная работа Git — формировать односвязный список из коммитов. Подавляющее большинство команд Git — это всего лишь небольшие программы, которые умеют ходить по этому списку и извлекать нужную информацию. Фактически все сводится к тому, что мы блуждаем по этому списку, меняем его и добавляем новые коммиты.

Ветки
Если смотреть дальше, то мы увидим, что цепочка коммитов в Git это не просто односвязный список. Это направленный ациклический граф — множество односвязных списков, переплетенных вместе.

Представьте себе, что в один момент два разных человека должны делать какие-то длинные задачи, требующие нескольких дней разработки или даже больше. В таком случае main-ветка должна оставаться рабочей: коммитить промежуточные изменения в нее нельзя, так как изменения могут сломать код. Но коммитить все равно надо, потому что просто небезопасно копить изменения в рабочей директории, не отправляя их в Git. Что делать в такой ситуации?

Git позволяет отпочковаться от основного списка — сформировать ветку. То есть создается отдельный список коммитов, который идет мимо главной ветки. В конце разработки все коммиты из такой ветки вливаются обратно в main-ветку

git switch branch – переключение на ветку с именем branch



	Игнорирование файлов—

В процессе работы над любым проектом в директории с кодом создаются файлы, которые не являются частью исходного кода. Все эти файлы можно условно разделить на несколько групп:

1.Инструментарий

	Служебные файлы, добавляемые операционной системой — например, .DS_Store в MacOS
	
	Конфигурационные и временные файлы редакторов — например, .idea или .vscode

2.Временные файлы

	Логи — в них содержится полезная информация для отладки, которая собирается во время запуска и работы приложения
	
	Кеши — файлы, которые нужны для ускорения разных процессов
3.Артефакты

	Результаты сборки проекта — например, после компиляции или сборки фронтенда
	
	Зависимости, которые устанавливаются во время разработки — например, node_modules или vendor

	Результаты выполнения тестов — например, информация о покрытии кода тестами


Все это в обычной ситуации не должно попадать в репозиторий. В этом уроке вы узнаете, как проигнорировать эти файлы.

Как правило, эти файлы не несут никакой пользы с точки зрения исходного кода. Они создаются:

1.Автоматически (кеши, логи)

2.По запросу (например, скачиваются зависимости или собирается проект)

Главная проблема с этими файлами в их постоянном изменении — особенно при очень больших размерах проекта. Если добавлять их в репозиторий, то практически в каждом коммите будут не только изменения исходного кода, но и пачка изменений в этих файлах. Читать историю таких коммитов крайне сложно.

Git позволяет гибко настраивать игнорирование определенных файлов и директорий. Делается это с помощью файла .gitignore, который нужно создать в корне проекта. В этот файл с помощью текстового редактора добавляются имена файлов и директорий, которые надо игнорировать:

# В этом файле можно оставлять комментарии
# Имя файла .gitignore
# Файл нужно создать самостоятельно

# Каждая строчка — это шаблон, по которому происходит игнорирование

# Игнорируем файл в любой директории проекта
access.log

# Игнорируем директорию в любой директории проекта
node_modules/

# Игнорируем каталог в корне рабочей директории
/coverage/

# Игнорируем все файлы с расширением sqlite3 в директории db
# При этом не игнорируются такие же файлы внутри любого вложенного каталога в db
# Например, /db/something/lala.sqlite3
/db/*.sqlite3

# Игнорировать все .txt файлы в каталоге doc/ на всех уровнях вложенности
doc/**/*.txt
Git поддерживает игнорирование файлов, но сам его не настраивает. Для игнорирования файлов и директорий, программист должен создать файл .gitignore в корне проекта и добавить его в репозиторий. Пример вы можете посмотреть здесь.

Продолжим работать с .gitignore:

touch .gitignore
# Добавляем в файл правила игнорирования по примеру выше
git add .gitignore
git commit -m 'update gitignore'
Как только .gitignore создан и в него добавлен какой-то файл или директория, игнорирование заработает автоматически. Все новые файлы, попадающие под игнорирование, не отобразятся в выводе команды git status.

Иногда бывает такое, что программист случайно уже добавил в репозиторий файл, который нужно проигнорировать. В этой ситуации недостаточно обновить правила игнорирования. Дополнительно придется удалить файл или директорию из Git с помощью git rm и закоммитить.

У git rm есть опция --cached. Если её использовать, файл будет удален из репозитория (гит перестанет отслеживать любые изменения), но не из рабочей директории


	Stash—

Представьте себе ситуацию. Вы работаете над какой-то важной задачей и исправили довольно много файлов. В этот момент появляется срочная задача — сделать какое-то изменение в исходном коде, не связанное с тем, над чем вы сейчас работаете. Ваши изменения еще не готовы, и они не должны попасть в репозиторий. Что делать? В этом уроке мы разберем команду, которая поможет в этом случае.

В самом простом случае, ваши изменения не пересекаются с изменениями по срочной задаче. В таком случае вы можете внести исправления, добавить их в индекс, закоммитить и запушить. Но обычно это неудобно и не всегда возможно. А если изменения нужно делать в тех файлах, с которыми вы работаете прямо сейчас?

Подобная ситуация у опытных разработчиков встречается регулярно. К счастью, она легко решается. В Git существует набор команд, позволяющий прятать изменения в рабочей директории и восстанавливать их при необходимости. Попробуем:

touch FILE.md
git add FILE.md
git status

On branch main
Your branch is up to date with 'origin/main'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
    new file:   FILE.md

# Прячем файлы
# После этой команды пропадут все измененные файлы
# независимо от того, добавлены они в индекс или нет
git stash

Saved working directory and index state WIP on main: e7bb5e5 update README.md

git status

On branch main
Your branch is up to date with 'origin/main'.

nothing to commit, working tree clean


Команда git stash не удаляет файлы. Они попадают в специальное место внутри директории .git на временное хранение. Эта команда не трогает новые файлы, так как они еще не являются частью репозитория


После выполнения всех нужных изменений в чистой рабочей директории можно вернуть спрятанные изменения с помощью команды git stash pop:

# Восстанавливаем
git stash pop

On branch main
Your branch is up to date with 'origin/main'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
    new file:   FILE.md

Dropped refs/stash@{0} (b896d4a0126ef4409ede63857e5d996953fe75c5)

# Проверяем
git status

On branch main
Your branch is up to date with 'origin/main'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
    new file:   FILE.md


Файлы вернулись в том виде, в котором они попали в стэш (stash).

Стэш в Git работает по принципу стека. Он позволяет сохранить внутрь любое количество изменений и восстановить их в обратном порядке:

git stash

# Изменяем файлы
git stash

# Возвращаем последние изменения
git stash pop

# Возвращаем предпоследние изменения
git stash pop



	Открытые проекты—

Как и все программисты, каждый день мы пользуемся программным обеспечением с открытым исходным кодом. В этом уроке мы обсудим, что это такое. Вы узнаете, чем открытый код полезен программисту.

Проекты с открытым исходным кодом или OpenSource (Open Source Software, OSS) — это программное обеспечение с общедоступным кодом. Любой пользователь может увидеть код, а в большинстве случаев — даже повлиять на него.

К такому ПО относятся:

1.Прикладное ПО и сервисы, как VSCode или Git

2.Огромное число библиотек в нашем коде

3.Практически все современные языки программирования


Современные проекты огромны:

Linux (> 12 000 000 строк кода)

Chromium (> 16 000 000 строк кода)


Та скорость, с которой разрабатываются такие крупные проекты, возможна благодаря программам и библиотекам с открытым исходным кодом.

Откуда вообще берутся опенсорс-проекты, и почему они так популярны? Почти всегда такой код появляется как побочный продукт разработки других проектов. Например, в процессе разработки Linux появилась необходимость в удобной программе для управления версиями — так появился Git.

Но почему его код был открыт? Ответ достаточно простой. Удачные проекты привлекают множество разработчиков, которые помогают им развиваться. Они пишут отчеты об ошибках, присылают исправления и даже становятся полноправными разработчиками. И все это бесплатно. Разработчики удовлетворяют свое эго и радуются тому, что создают нечто новое и вообще помогают этой Вселенной. Как побочный эффект, такие разработчики гораздо легче находят работу и имеют более прокачанные навыки кодирования, чем их коллеги, которые не работают с открытыми проектами.

Если вы вернетесь в прошлое и посмотрите, сколько людей раньше работало над опенсорс-проектами, то вы увидите огромный разрыв с современным положением дел.

Сложное включение в разработку, сложное принятие изменений — вот неполный перечень проблем, с которыми сталкивались участники опенсорс-движения. Раньше было нормой, что люди выступали с докладами на конференциях, где час описывали правила принятия людей и кода от них в проект.

Сейчас присоединиться к опенсорс-проекту можно за пару минут. Можно начать где-то участвовать, не нужно прилагать практически никаких усилий. Случилось это благодаря двум составляющим: Git и GitHub.

Один из важнейших механизмов GitHub — запрос на включение изменений. Коротко его называют пулреквест (pull request). Именно этот механизм позволяет легко и непринужденно вливаться в разработку любых проектов.

Допустим, работая с определенной библиотекой, мы заметили ошибку в коде или документации. Пройдемся по шагам, которые необходимо выполнить для исправления этой ошибки. Наша конечная цель — чтобы разработчики библиотеки приняли код.

	Клонирование
Первым шагом создаем копию репозитория в своем аккаунте. Делается это буквально одной кнопкой Fork на странице репозитория

После этого действия в вашем аккаунте окажется репозиторий с таким же именем. GitHub знает, что это копия оригинального репозитория, и помечает его особым образом.

Дальше все как обычно. Мы клонируем репозиторий на компьютер и производим необходимые изменения. Хорошей практикой считается делать изменения в отдельной ветке, созданной от ветки main.

Запрос на включение изменений кода

После того как мы залили изменения на GitHub, в его интерфейсе произойдут изменения. На странице склонированного репозитория появится кнопка Pull request

Если ее нажать, то откроется страница, на которой можно указать название пулреквеста и его описание.

После отправки пулреквеста в оригинальном репозитории на странице Pull requests отобразится ваш запрос. Теперь остается ждать, когда разработчики библиотеки рассмотрят пулреквест. В итоге они:

	Либо примут реквест

	Либо отклонят его

	Либо зададут уточняющие вопросы и предложат доработать реквест

	
	
	Исправления прямо на GitHub

В более простых ситуациях, когда достаточно исправить текст или опечатку, GitHub позволяет сделать пулреквест прямо из своего интерфейса.

Для этого достаточно открыть любой файл проекта и нажать на иконку редактирования. После завершения редактирования GitHub сам предложит создать пулреквест с этим изменением.






