		Команды для  git
		
Git может отслеживать файлы проекта только в том случае, когда они помещены под контроль версий. Для этого нужно зайти в директорию проекта и выполнить команду инициализации git init.

Проект может быть как новый, так и уже существующий. Процесс инициализации от этого не поменяется:

# Создаем новый проект
mkdir hexlet-git

# Переходим в созданную директорию
cd hexlet-git

# Выполняем инициализацию
git init

Initialized empty Git repository in /private/tmp/hexlet-git/.git/

Команда git init создает репозиторий — директорию .git, которая содержит все необходимые для работы Git-файлы.

С помощью команды git status можно посмотреть статус репозитория:

git status

On branch main
No commits yet
nothing to commit (create/copy files and use "git add" to track)

В этом выводе указано, что репозиторий пустой (No commits yet) — в нем нет новых или измененных файлов.

Давайте попробуем добавить несколько файлов:

# Создаем файл README.md со строкой текста
echo 'Hello, Hexlet!' > README.md
echo 'Haskell Curry' > PEOPLE.md

Теперь снова смотрим на статус:

git status

# Часть вывода убрана
Untracked files:
  (use "git add <file>..." to include in what will be committed)
    PEOPLE.md
    README.md
Git увидел, что в проекте появились новые файлы, о которых ему ничего не известно. Они помечаются как неотслеживаемые файлы (untracked files).

Git не следит за изменениями в таких файлах, потому что они не добавлены в репозиторий.


Добавление в репозиторий происходит в два шага. Первым шагом выполняем команду подготовки файлов git add <путь до файла>:

# Для каждого нового или измененного файла
git add README.md
Смотрим, что произошло:

git status

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
    new file:   README.md

Untracked files:
  (use "git add <file>..." to include in what will be committed)
    PEOPLE.md


Файл README.md теперь находится в состоянии «подготовлен к коммиту» — другими словами, файл попал в индекс.

Следующий шаг — это коммит. Под этим термином понимается окончательное добавление в репозиторий, когда Git запоминает файл навсегда и следит за всеми последующими изменениями.

Во время коммита мы берем все подготовленные изменения (они могут включать любое количество файлов) и отправляем их в репозиторий как единое целое. Вот, как он выполняется:

git commit -m 'add README.md'

[main (root-commit) 3c5d976] add README.md
1 file changed, 1 insertion(+)
create mode 100644 README.md



Флаг -m означает message, то есть описание коммита. Коммит можно выполнять и без него, но тогда откроется редактор, в котором нужно будет ввести описание коммита.

Мы рекомендуем делать осмысленные описания — это хороший тон. Пример соглашения по именованию коммитов приведен в дополнительных материалах к уроку.


Со смысловой точки зрения, коммит — это какое-то логически завершенное изменение внутри проекта. Его размер бывает очень разным:

Маленьким, если мы исправляем одну опечатку в одном файле
Большим, если мы внедряем новую функциональность
Главное в коммите — его атомарность. Другими словами, он должен выполнять ровно одну задачу.

Теперь файл README.md находится внутри репозитория. Убедиться в этом можно, запустив команду git status:

git status

Untracked files:
  (use "git add <file>..." to include in what will be committed)
    PEOPLE.md
Команда git status не выводит файлы, которые добавлены в репозиторий и не содержат изменений. При этом сам файл README.md находится внутри директории hexlet-git.

Сохраненный репозиторий в любой момент можно извлечь и продолжить работу в нем с последнего добавленного коммита. Это пригодится, если мы случайно удалим или изменим локальный репозиторий так, что с ним станет невозможно работать.



	Добавим наш репозиторий на GitHub:

Зарегистрируйтесь на GitHub и создайте ssh-ключи по инструкции. SSH-ключи — это наиболее безопасный способ работы с GitHub, поэтому важно разобраться с ними
Создайте репозиторий на GitHub. Назовите его hexlet-git. Важно, чтобы репозиторий создавался пустым, поэтому не отмечайте галочки, добавляющие файлы
На странице репозитория вы увидите готовые команды для подключения созданного репозитория на GitHub к уже существующему репозиторию у вас на компьютере:


Выполните эти шаги:

# Подробнее эти команды мы разберем позже
# Вам нужна ссылка для работы с репозиторием по SSH
git remote add origin git@github.com:<ИМЯ НА ГИТХАБЕ>/hexlet-git.git
git branch -M main
git push -u origin main
Обновите страницу с репозиторием на GitHub. Изучите ее интерфейс и содержимое репозитория. Обратите внимание, что директория .git отсутствует. Почему это так, мы узнаем в одном из следующих уроков

	Как клонировать репозиторий
Репозитории на GitHub делятся на публичные и приватные. Публичный репозиторий любой человек может клонировать себе на компьютер. После клонирования он начнет работать с ним как с личным.

Единственное ограничение — он не сможет запушить изменения, так как GitHub не дает напрямую менять чужие репозитории.

Клонирование — базовая операция при работе с удаленными репозиториями. Проекты, над которыми работают программисты, всегда находятся в системах, подобных GitHub. Для работы с ними нужно клонировать репозиторий к себе на компьютер.

Клонировать репозиторий можно с помощью команды git clone. Полную команду для клонирования можно получить на странице репозитория. Для этого нажмите большую кнопку Code, перейдите на вкладку SSH и скопируйте содержимое:

git clone git@github.com:<ИМЯ НА ГИТХАБЕ>/hexlet-git.git
cd hexlet-git
ls -la

# Если эта операция проходит первый раз,
# То вы можете увидеть такое подобное сообщение
The authenticity of host github.com cannot be established. RSA key fingerprint is SHA256: хххххххххх Are you sure you want to continue connecting (yes/no/[fingerprint])? yes Warning: Permanently added github.com (RSA) to the list of known hosts.
# Наберите yes и нажмите Enter
Мы получили точную копию репозитория, который был у нас до удаления директории hexlet-git.

	Как получить изменения с GitHub
Разработчики не только отправляют свои изменения на GitHub, но и забирают их оттуда. Чаще всего это изменения, сделанные другими разработчиками проекта, но необязательно. Бывает такое, что один разработчик работает над одним проектом с разных компьютеров, на каждом из которых своя собственная копия репозитория.

В таком случае, перед началом работы нужно всегда выполнять команду git pull --rebase, которая скачивает из внешнего репозитория новые коммиты и добавляет их в локальный репозиторий.

Считается, что достаточно вызывать git pull, но это может приводить к созданию ненужных коммитов, из-за которых становится сложнее следить за историей изменений.


	После клонирования репозитория hexlet-git мы можем увидеть внутри него директорию .git и добавленные нами файлы. Посмотрим, что произойдет, если удалить один из файлов:

rm PEOPLE.md
git status

On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
    deleted:    PEOPLE.md

no changes added to commit (use "git add" and/or "git commit -a")
Git сообщает, что файл был удален, и предлагает команды для восстановления или коммита изменений.



Внутри директории проекта мы видим файлы проекта с одной стороны и директорию .git с другой.

Репозиторием является именно директория .git. Она хранит всю информацию о том, какие были изменения, а также сами изменения.

А вот все, что находится снаружи, это так называемая рабочая директория (working directory). Эти файлы извлекаются из .git в момент клонирования.

Каждый раз, когда мы производим изменения в рабочей директории, Git сравнивает измененные файлы с файлами внутри .git, то есть их состоянием на момент последнего коммита. Если есть изменения относительно последней зафиксированной версии, то Git сообщает нам об этом в выводе команды git status.

В этом очень легко убедиться, если последовать совету Git в выводе выше и восстановить удаленный файл:

git restore PEOPLE.md
git status

On branch main
Your branch is up to date with 'origin/main'.

nothing to commit, working tree clean

# Сам файл вернулся таким, каким он был на момент последнего коммита
Можно удалить все файлы в рабочей директории и потом без проблем их восстановить. Так мы достигаем важной цели — создаем возможность быстро восстановить последнюю версию кода, если внесенные изменения нас больше не устраивают.

Еще мы можем закоммитить их, если это нужно:

rm PEOPLE.md
# Любое изменение нужно добавлять в индекс
git add PEOPLE.md
git commit -m 'remove PEOPLE.md'

[main e15afd2] remove PEOPLE.md
1 file changed, 1 deletion(-)
delete mode 100644 PEOPLE.md
# Теперь этот файл пропал из рабочей директории
Обратите внимание на важную деталь. Независимо от того, удаляем мы файл, добавляем или меняем, процедура выполнения коммита не меняется. После изменений всегда делается git add, который подготавливает изменение к коммиту (а не добавляет файл). После этого выполняется коммит.

Кстати, у Git есть команда git rm, которая объединяет в себе удаление и подготовку к коммиту:

git rm PEOPLE.md
# Равносильно rm + git add


	Git diff


Анализировать изменения важно даже в небольших проектах. Прямо сейчас во время разработки этого курса изменилось несколько файлов и git status выглядит так:

git status

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
    modified:   300-working-directory/README.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
    modified:   100-intro/README.md
    modified:   250-github/README.md
    modified:   300-working-directory/README.md
    modified:   300-working-directory/spec.yml
    modified:   350-changes/README.md
Попробуем воспроизвести подобную ситуацию в нашем проекте. Выполним следующий код в репозитории hexlet-git:

echo 'new line' >> INFO.md
echo 'Hello, Hexlet! How are you?' > README.md

git status

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
    modified:   INFO.md
    modified:   README.md

no changes added to commit (use "git add" and/or "git commit -a")
Изменились оба файла. В один файл мы добавили строчку, в другом — заменили. Как теперь посмотреть эти изменения?

Для этого в Git есть команда git diff, которая показывает разницу между тем, что было и что стало:

git diff

diff --git a/INFO.md b/INFO.md
index d5225f8..40f51f1 100644
--- a/INFO.md
+++ b/INFO.md
@@ -1 +1,2 @@

 git is awesome!
+new line

diff --git a/README.md b/README.md
index ffe7ece..00fd294 100644
--- a/README.md
+++ b/README.md
@@ -1 +1 @@

-Hello, Hexlet!
+Hello, Hexlet! How are you?
Вывод команды поначалу может смутить. Здесь довольно много служебных данных, за которыми уже идут изменения.

Вывод git diff содержит не файлы целиком, а именно те строки, которые изменились — и иногда строки вокруг измененных для удобства анализа.

Слева от строк ставится:

Знак -, если строка была удалена
Знак +, если строка была добавлена
Сама команда не просто выводит на экран разницу между файлами, но и запускает пейджер — специальную программу, которая позволяет перемещаться по выводу и искать внутри него нужные данные. Для этого используются клавиши:

'f' — перемещение вниз
'b' или 'u' — перемещение вверх
'q' — или выход из режима просмотра
По умолчанию команда git diff показывает изменения только для тех модифицированных файлов, которые еще не были добавлены в индекс. Подразумевается, что добавленные в индекс файлы смотреть не нужно, ведь мы их уже подготовили к коммиту. Но лучше еще раз увидеть эти изменения и все проверить. Для этого нужно запустить команду git diff с флагом --staged:

# Выведет все изменения, сделанные в рабочей директории
# которые были добавлены в индекс
git diff --staged
В целом, git diff — команда, которую нужно обязательно запускать перед каждым коммитом. С ее помощью можно проанализировать добавляемые изменения и исправить возможные ошибки, ведь иногда программисты случайно добавляют в коммит то, что туда не должно попасть.


	Анализ истории изменений

	
Программирование — это не только написание новых программ, но и постоянный анализ уже написанного кода. Иногда код понятен и без слов — и это хороший код.

Но так происходит не всегда. Код может вызывать вопросы. Почему он написан именно так, кто его написал и когда.

Ответить на эти вопросы помогает история изменений. Хорошо сделанные коммиты имеют понятное описание, и каждый из них делает ровно одну законченную вещь — в таком случае история становится мощным инструментом для анализа кода. Именно поэтому так важно хорошо понимать философию Git и следовать лучшим практикам при работе с ним.

Git предоставляет целую пачку команд со множеством опций, позволяющих вытащить невероятное количество информации и показать все, что скрыто. С ними мы познакомимся в этом уроке.

Команда git log
Самая простая аналитика выполняется командой git log. Она показывает список всех выполненных коммитов, отсортированных по дате добавления. Сверху мы видим самые последние коммиты:

git log

# Ниже неполный вывод истории проекта

commit 5120bea3e5528c29f8d1da43731cbe895892eb6d
Author: tirion <tirion@got.com>
Date:   Thu Sep 17 18:04:19 2020 -0400

    add new content

commit e6f625cf8433c8b1f1aaed58cd2b437ec8a60f27
Author: tirion <tirion@got.com>
Date:   Thu Sep 17 16:14:09 2020 -0400

    add INFO.md

commit 273f81cf2117044f1973ea80ce1067a94bea3f80
Author: tirion <tirion@got.com>
Date:   Thu Sep 17 16:08:39 2020 -0400

    remove NEW.md

# Этот вывод показывается через пейджер
Из этого вывода мы можем узнать кто, когда и какие коммиты делал. Если коммиты оформлены хорошо, то по их описанию уже многое понятно. Оформление коммитов — отдельная тема, которую мы рассмотрим позже.

У команды git log есть полезный флаг -p, который сразу выводит диф для каждого коммита:

git log -p
# Тут все коммиты с полным дифом
# Промотать вперед — кнопка f, промотать назад — b
# Выйти из режима просмотра — q	
	
	
	Команда git show
У каждого коммита есть уникальный набор символов — идентификатор (еще говорят «хеш»). С помощью хеша можно посмотреть все изменения, сделанные в рамках одного коммита:

git show 5120bea3e5528c29f8d1da43731cbe895892eb6d
# Тут выводится диф между этим коммитом и предыдущим

diff --git a/INFO.md b/INFO.md
index d5225f8..40f51f1 100644
--- a/INFO.md
+++ b/INFO.md
@@ -1 +1,2 @@
 git is awesome!
+new line
diff --git a/README.md b/README.md
index ffe7ece..00fd294 100644
--- a/README.md
+++ b/README.md
@@ -1 +1 @@
-Hello, Hexlet!
+Hello, Hexlet! How are you?
# Здесь мы видим, что было изменено этим коммитом
Хеши коммитов в Git очень длинные, и ими бывает неудобно пользоваться. Поэтому разработчики Git добавили возможность указывать только часть хеша. Достаточно взять первые семь символов и подставить их в ту команду, которая работает с коммитами:

git show 5120bea
Чаще всего вам не придется высчитывать их самим. Большая часть команд Git выводит хеш коммита в сокращенном варианте, облегчая его использование. Такое упрощение хорошо работает, потому что даже первые семь символов будут всегда уникальными.
	
	
	Команда git blame
А что если мы не знаем коммита, но нам интересно, кто последним менял конкретную строчку в файле? Для этого подойдет команда git blame <путь до файла>. Эта команда выводит файл и рядом с каждой строчкой показывает того, кто ее менял и в каком коммите:

git blame INFO.md

e6f625cf (tirion 2020-09-17 16:14:09 -0400 1) git is awesome!
5120bea3 (tirion 2020-09-17 18:04:19 -0400 2) new line
Важно помнить, что изменение строчки — не то же самое, что ее написание. Вполне возможно, что программист исправил небольшую опечатку, а саму строчку написал кто-то до него. Имея такой вывод, уже легко пойти дальше и изучить конкретный коммит.
	
	
	Команда git grep
Команда git grep ищет совпадение с указанной строкой во всех файлах проекта. Это очень удобная команда для быстрого анализа из терминала. Она удобнее обычного grep, потому что знает про игнорирование и не смотрит в директорию .git, а еще умеет искать по истории:

git grep line

INFO.md:new line

# Флаг `i` позволяет искать без учета регистра
git grep -i hexlet

README.md:Hello, Hexlet! How are you?

# Поиск в конкретном коммите
git grep Hexlet 5120bea

# Поиск по всей истории
# Возвращаем список хешей коммитов `rev-list`
git grep Hexlet $(git rev-list --all)	


	GitHub
В простых ситуациях анализировать проект можно прямо на GitHub. Он позволяет просматривать историю коммитов, изменения в конкретном коммите и многое другое.



	Отмена изменений в рабочей директории
	
Одна из ключевых возможностей Git — это откат любых сделанных изменений буквально одной командой. Такое практически невозможно сделать без использования системы контроля версий — только если помнить все изменения наизусть. В этом уроке мы поговорим про откат изменений, которые сделаны в рабочей директории, но еще не попали в коммит.

Отдельно отметим, что откат незакоммиченных изменений безвозвратен. Не существует никакой физической возможности получить эти изменения обратно, поэтому будьте крайне осторожны.

	Неотслеживаемые файлы
Это самая простая ситуация. Представьте, что вы добавили новые файлы в репозиторий и поняли, что они вам не нужны.

В этом случае можно выполнить очистку:

mkdir one
touch two

git status

On branch main
Your branch is up to date with 'origin/main'.

# Пустые директории в Git не добавляются в принципе
# Физически директория one находится в рабочей директории,
# но при этом ее нет в Git, поэтому Git игнорирует ее
Untracked files:
  (use "git add <file>..." to include in what will be committed)
    two

# Выполняем очистку. Команда удалит все незакоммиченные изменения
# -f – force, -d – directory
git clean -fd

Removing one/
Removing two


	Измененные файлы в рабочей директории
Для отмены изменений в таких файлах используется команда git restore. Причем Git сам напоминает об этом при проверке статуса:

echo 'new text' > INFO.md
git status

On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  # Ниже написано, как отменить изменение
  (use "git restore <file>..." to discard changes in working directory)
    modified:   INFO.md

# Отменяем
git restore INFO.md


	Изменения, подготовленные к коммиту
С файлами, подготовленными к коммиту, можно поступить по-разному. Первый вариант — отменить изменения совсем, второй — отменить только индексацию, не изменяя файлы в рабочей директории. Второе полезно в том случае, если изменения нужны, но мы не хотим их коммитить сейчас:

echo 'new text' > INFO.md
git add INFO.md
git status

On branch main
Your branch is up to date with 'origin/main'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
    modified:   INFO.md
И здесь снова помогает Git. При выводе статуса он показывает нужную команду для перевода изменений в рабочую директорию:

git restore --staged INFO.md
git status

On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
    modified:   INFO.md
Теперь, если нужно, можно выполнить git restore и окончательно отменить изменения в выбранных файлах


	Отмена коммитов


Git — система, в которой не нужно бояться совершать ошибки. Можно сказать, что ошибки — это единственный способ научиться им пользоваться. В Git практически всегда есть способ восстановить или изменить любые коммиты. На крайний случай спасет повторный git clone.

Что делать, если коммит уже сделан, но он нас по каким-то причинам не устраивает? Ситуаций может быть много, и все они возникают регулярно даже у профессиональных разработчиков:

Забыли добавить в коммит нужные файлы
Изменения нужно «откатить», чтобы доработать
Изменения больше не актуальны, и их нужно удалить
Изменения были сделаны по ошибке, и их нужно отменить

По большей части Git движется «только вперед». Правильный подход при работе с ним — это создавать новое, а не изменять старое.

Все ситуации, описанные выше, можно решить новым коммитом, изменяющим код в нужном направлении. Это не только удобно, но и безопасно. Изменение истории коммитов — опасная операция, которая чревата проблемами при синхронизации с удаленными репозиториями. Об этом мы поговорим позже.

Несмотря на сказанное выше, внутри Git существуют специальные команды, позволяющие упростить отмену, либо изменение коммита. С их помощью можно сделать историю коммитов понятной, а сам процесс отката — быстрым.

	Git revert
Самая простая ситуация — отмена изменений. Фактически она сводится к созданию еще одного коммита, который выполняет изменения, противоположные тому коммиту, который отменяется

Руками создавать подобный коммит довольно сложно, поэтому в Git добавили команду, автоматизирующую откат. Эта команда называется git revert:

# Этой команде нужен идентификатор коммита
# Это коммит, которым мы удалили файл PEOPLE.md
git revert aa600a43cb164408e4ad87d216bc679d097f1a6c
# После этой команды откроется редактор, ожидающий ввода описания коммита
# Обычно сообщение revert не меняют, поэтому достаточно просто закрыть редактор
[main 65a8ef7] Revert "remove PEOPLE.md"
 1 file changed, 1 insertion(+)
 create mode 100644 PEOPLE.md
# В проект вернулся файл PEOPLE.md

git log -p

commit 65a8ef7fd56c7356dcee35c2d05b4400f4467ca8
Author: tirion <tirion@got.com>
Date:   Sat Sep 26 15:32:46 2020 -0400

    Revert "remove PEOPLE.md"

    This reverts commit aa600a43cb164408e4ad87d216bc679d097f1a6c.

diff --git a/PEOPLE.md b/PEOPLE.md
new file mode 100644
index 0000000..4b34ba8
--- /dev/null
+++ b/PEOPLE.md
@@ -0,0 +1 @@
+Haskell Curry

Команда revert может отменять не только последний коммит, но и любой другой коммит из истории проекта. Согласитесь, это очень круто. Без системы контроля версий о таком нельзя было и мечтать.

	Команда git reset
Представьте, что вам нужно удалить только что сделанный по ошибке коммит. Конечно, и в этом случае подходит git revert, но так история становится менее читаемой. Если этот коммит сделан был только сейчас и еще не отправлялся на GitHub, то лучше сделать так, как будто бы этого коммита не существовало в принципе.

Git позволяет удалять коммиты. Это опасная операция, которую нужно делать только в том случае, если речь идет про новые коммиты, которых нет ни у кого, кроме вас.

Если коммит был отправлен во внешний репозиторий, например, на GitHub, то менять историю ни в коем случае нельзя. Это сломает работу у тех, кто работает с вами над проектом.

Для удаления коммита используется команда git reset:

# Добавляем новый коммит, который мы сразу же удалим
echo 'test' >> INFO.md
git add INFO.md
git commit -m 'update INFO.md'

[main 17a77cb] update INFO.md
 1 file changed, 1 insertion(+)
 # Важно, что мы не делаем git push

git reset --hard HEAD~

HEAD is now at 65a8ef7 Revert "remove PEOPLE.md"

# Если посмотреть `git log`, то последнего коммита там больше нет

У команды git reset есть множество различных флагов и способов работы. С ее помощью можно удалять коммиты, отменять их без удаления, восстанавливать файлы из истории и так далее. Работа с ней относится к продвинутому использованию Git, но здесь мы затрагиваем только самую базу.

Флаг --hard означает полное удаление. Без него git reset отменит коммит, но не удалит его, а поместит все изменения этого коммита в рабочую директорию, так что с ними можно будет продолжить работать.

Флаг HEAD~ означает «один коммит от последнего коммита». Обратите внимание, что здесь используется знак ~ — тильда. Его легко перепутать с дефисом -. Если бы мы хотели удалить два последних коммита, то могли бы написать HEAD~2:


HEAD (переводится как «голова») — так обозначается последний сделанный коммит. Подробнее эту терминологию мы разберем в уроке, посвященном внутреннему устройству Git.

Если не указывать флаг --hard, то по умолчанию подразумевается флаг --mixed. В таком варианте git reset отправляет изменения последнего коммита в рабочую директорию. Затем их можно исправить или отменить и выполнить новый коммит:

echo 'no code no pain' > README.md
git add README.md
git commit -m 'update README.md'

[main f85e3a6] update README.md
 1 file changed, 1 insertion(+)

# Теперь откатываем последний коммит
git reset HEAD~

Unstaged changes after reset:
M   README.md

git status

On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
    modified:   README.md
Последнего коммита больше не существует. При этом сделанные в нем изменения не пропали. Они находятся в рабочей директории для дальнейшей доработки.













