		Команды для  git
		
Git может отслеживать файлы проекта только в том случае, когда они помещены под контроль версий. Для этого нужно зайти в директорию проекта и выполнить команду инициализации git init.

Проект может быть как новый, так и уже существующий. Процесс инициализации от этого не поменяется:

# Создаем новый проект
mkdir hexlet-git

# Переходим в созданную директорию
cd hexlet-git

# Выполняем инициализацию
git init

Initialized empty Git repository in /private/tmp/hexlet-git/.git/

Команда git init создает репозиторий — директорию .git, которая содержит все необходимые для работы Git-файлы.

С помощью команды git status можно посмотреть статус репозитория:

git status

On branch main
No commits yet
nothing to commit (create/copy files and use "git add" to track)

В этом выводе указано, что репозиторий пустой (No commits yet) — в нем нет новых или измененных файлов.

Давайте попробуем добавить несколько файлов:

# Создаем файл README.md со строкой текста
echo 'Hello, Hexlet!' > README.md
echo 'Haskell Curry' > PEOPLE.md

Теперь снова смотрим на статус:

git status

# Часть вывода убрана
Untracked files:
  (use "git add <file>..." to include in what will be committed)
    PEOPLE.md
    README.md
Git увидел, что в проекте появились новые файлы, о которых ему ничего не известно. Они помечаются как неотслеживаемые файлы (untracked files).

Git не следит за изменениями в таких файлах, потому что они не добавлены в репозиторий.


Добавление в репозиторий происходит в два шага. Первым шагом выполняем команду подготовки файлов git add <путь до файла>:

# Для каждого нового или измененного файла
git add README.md
Смотрим, что произошло:

git status

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
    new file:   README.md

Untracked files:
  (use "git add <file>..." to include in what will be committed)
    PEOPLE.md


Файл README.md теперь находится в состоянии «подготовлен к коммиту» — другими словами, файл попал в индекс.

Следующий шаг — это коммит. Под этим термином понимается окончательное добавление в репозиторий, когда Git запоминает файл навсегда и следит за всеми последующими изменениями.

Во время коммита мы берем все подготовленные изменения (они могут включать любое количество файлов) и отправляем их в репозиторий как единое целое. Вот, как он выполняется:

git commit -m 'add README.md'

[main (root-commit) 3c5d976] add README.md
1 file changed, 1 insertion(+)
create mode 100644 README.md



Флаг -m означает message, то есть описание коммита. Коммит можно выполнять и без него, но тогда откроется редактор, в котором нужно будет ввести описание коммита.

Мы рекомендуем делать осмысленные описания — это хороший тон. Пример соглашения по именованию коммитов приведен в дополнительных материалах к уроку.


Со смысловой точки зрения, коммит — это какое-то логически завершенное изменение внутри проекта. Его размер бывает очень разным:

Маленьким, если мы исправляем одну опечатку в одном файле
Большим, если мы внедряем новую функциональность
Главное в коммите — его атомарность. Другими словами, он должен выполнять ровно одну задачу.

Теперь файл README.md находится внутри репозитория. Убедиться в этом можно, запустив команду git status:

git status

Untracked files:
  (use "git add <file>..." to include in what will be committed)
    PEOPLE.md
Команда git status не выводит файлы, которые добавлены в репозиторий и не содержат изменений. При этом сам файл README.md находится внутри директории hexlet-git.

Сохраненный репозиторий в любой момент можно извлечь и продолжить работу в нем с последнего добавленного коммита. Это пригодится, если мы случайно удалим или изменим локальный репозиторий так, что с ним станет невозможно работать.



	Добавим наш репозиторий на GitHub:

Зарегистрируйтесь на GitHub и создайте ssh-ключи по инструкции. SSH-ключи — это наиболее безопасный способ работы с GitHub, поэтому важно разобраться с ними
Создайте репозиторий на GitHub. Назовите его hexlet-git. Важно, чтобы репозиторий создавался пустым, поэтому не отмечайте галочки, добавляющие файлы
На странице репозитория вы увидите готовые команды для подключения созданного репозитория на GitHub к уже существующему репозиторию у вас на компьютере:


Выполните эти шаги:

# Подробнее эти команды мы разберем позже
# Вам нужна ссылка для работы с репозиторием по SSH
git remote add origin git@github.com:<ИМЯ НА ГИТХАБЕ>/hexlet-git.git
git branch -M main
git push -u origin main
Обновите страницу с репозиторием на GitHub. Изучите ее интерфейс и содержимое репозитория. Обратите внимание, что директория .git отсутствует. Почему это так, мы узнаем в одном из следующих уроков

	Как клонировать репозиторий
Репозитории на GitHub делятся на публичные и приватные. Публичный репозиторий любой человек может клонировать себе на компьютер. После клонирования он начнет работать с ним как с личным.

Единственное ограничение — он не сможет запушить изменения, так как GitHub не дает напрямую менять чужие репозитории.

Клонирование — базовая операция при работе с удаленными репозиториями. Проекты, над которыми работают программисты, всегда находятся в системах, подобных GitHub. Для работы с ними нужно клонировать репозиторий к себе на компьютер.

Клонировать репозиторий можно с помощью команды git clone. Полную команду для клонирования можно получить на странице репозитория. Для этого нажмите большую кнопку Code, перейдите на вкладку SSH и скопируйте содержимое:

git clone git@github.com:<ИМЯ НА ГИТХАБЕ>/hexlet-git.git
cd hexlet-git
ls -la

# Если эта операция проходит первый раз,
# То вы можете увидеть такое подобное сообщение
The authenticity of host github.com cannot be established. RSA key fingerprint is SHA256: хххххххххх Are you sure you want to continue connecting (yes/no/[fingerprint])? yes Warning: Permanently added github.com (RSA) to the list of known hosts.
# Наберите yes и нажмите Enter
Мы получили точную копию репозитория, который был у нас до удаления директории hexlet-git.

	Как получить изменения с GitHub
Разработчики не только отправляют свои изменения на GitHub, но и забирают их оттуда. Чаще всего это изменения, сделанные другими разработчиками проекта, но необязательно. Бывает такое, что один разработчик работает над одним проектом с разных компьютеров, на каждом из которых своя собственная копия репозитория.

В таком случае, перед началом работы нужно всегда выполнять команду git pull --rebase, которая скачивает из внешнего репозитория новые коммиты и добавляет их в локальный репозиторий.

Считается, что достаточно вызывать git pull, но это может приводить к созданию ненужных коммитов, из-за которых становится сложнее следить за историей изменений.


	После клонирования репозитория hexlet-git мы можем увидеть внутри него директорию .git и добавленные нами файлы. Посмотрим, что произойдет, если удалить один из файлов:

rm PEOPLE.md
git status

On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
    deleted:    PEOPLE.md

no changes added to commit (use "git add" and/or "git commit -a")
Git сообщает, что файл был удален, и предлагает команды для восстановления или коммита изменений.



Внутри директории проекта мы видим файлы проекта с одной стороны и директорию .git с другой.

Репозиторием является именно директория .git. Она хранит всю информацию о том, какие были изменения, а также сами изменения.

А вот все, что находится снаружи, это так называемая рабочая директория (working directory). Эти файлы извлекаются из .git в момент клонирования.

Каждый раз, когда мы производим изменения в рабочей директории, Git сравнивает измененные файлы с файлами внутри .git, то есть их состоянием на момент последнего коммита. Если есть изменения относительно последней зафиксированной версии, то Git сообщает нам об этом в выводе команды git status.

В этом очень легко убедиться, если последовать совету Git в выводе выше и восстановить удаленный файл:

git restore PEOPLE.md
git status

On branch main
Your branch is up to date with 'origin/main'.

nothing to commit, working tree clean

# Сам файл вернулся таким, каким он был на момент последнего коммита
Можно удалить все файлы в рабочей директории и потом без проблем их восстановить. Так мы достигаем важной цели — создаем возможность быстро восстановить последнюю версию кода, если внесенные изменения нас больше не устраивают.

Еще мы можем закоммитить их, если это нужно:

rm PEOPLE.md
# Любое изменение нужно добавлять в индекс
git add PEOPLE.md
git commit -m 'remove PEOPLE.md'

[main e15afd2] remove PEOPLE.md
1 file changed, 1 deletion(-)
delete mode 100644 PEOPLE.md
# Теперь этот файл пропал из рабочей директории
Обратите внимание на важную деталь. Независимо от того, удаляем мы файл, добавляем или меняем, процедура выполнения коммита не меняется. После изменений всегда делается git add, который подготавливает изменение к коммиту (а не добавляет файл). После этого выполняется коммит.

Кстати, у Git есть команда git rm, которая объединяет в себе удаление и подготовку к коммиту:

git rm PEOPLE.md
# Равносильно rm + git add


	Git diff


Анализировать изменения важно даже в небольших проектах. Прямо сейчас во время разработки этого курса изменилось несколько файлов и git status выглядит так:

git status

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
    modified:   300-working-directory/README.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
    modified:   100-intro/README.md
    modified:   250-github/README.md
    modified:   300-working-directory/README.md
    modified:   300-working-directory/spec.yml
    modified:   350-changes/README.md
Попробуем воспроизвести подобную ситуацию в нашем проекте. Выполним следующий код в репозитории hexlet-git:

echo 'new line' >> INFO.md
echo 'Hello, Hexlet! How are you?' > README.md

git status

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
    modified:   INFO.md
    modified:   README.md

no changes added to commit (use "git add" and/or "git commit -a")
Изменились оба файла. В один файл мы добавили строчку, в другом — заменили. Как теперь посмотреть эти изменения?

Для этого в Git есть команда git diff, которая показывает разницу между тем, что было и что стало:

git diff

diff --git a/INFO.md b/INFO.md
index d5225f8..40f51f1 100644
--- a/INFO.md
+++ b/INFO.md
@@ -1 +1,2 @@

 git is awesome!
+new line

diff --git a/README.md b/README.md
index ffe7ece..00fd294 100644
--- a/README.md
+++ b/README.md
@@ -1 +1 @@

-Hello, Hexlet!
+Hello, Hexlet! How are you?
Вывод команды поначалу может смутить. Здесь довольно много служебных данных, за которыми уже идут изменения.

Вывод git diff содержит не файлы целиком, а именно те строки, которые изменились — и иногда строки вокруг измененных для удобства анализа.

Слева от строк ставится:

Знак -, если строка была удалена
Знак +, если строка была добавлена
Сама команда не просто выводит на экран разницу между файлами, но и запускает пейджер — специальную программу, которая позволяет перемещаться по выводу и искать внутри него нужные данные. Для этого используются клавиши:

'f' — перемещение вниз
'b' или 'u' — перемещение вверх
'q' — или выход из режима просмотра
По умолчанию команда git diff показывает изменения только для тех модифицированных файлов, которые еще не были добавлены в индекс. Подразумевается, что добавленные в индекс файлы смотреть не нужно, ведь мы их уже подготовили к коммиту. Но лучше еще раз увидеть эти изменения и все проверить. Для этого нужно запустить команду git diff с флагом --staged:

# Выведет все изменения, сделанные в рабочей директории
# которые были добавлены в индекс
git diff --staged
В целом, git diff — команда, которую нужно обязательно запускать перед каждым коммитом. С ее помощью можно проанализировать добавляемые изменения и исправить возможные ошибки, ведь иногда программисты случайно добавляют в коммит то, что туда не должно попасть.







